


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html id="htmlId">
<head>
  <title>Coverage Report :: DateTimeZoneBuilder</title>
  <style type="text/css">
    @import "../../.css/coverage.css";
  </style>
</head>

<body>
<div class="header"></div>

<div class="content">
<div class="breadCrumbs">
    [ <a href="../../index.html">all classes</a> ]
    [ <a href="../index.html">org.joda.time.tz</a> ]
</div>

<h1>Coverage Summary for Class: DateTimeZoneBuilder (org.joda.time.tz)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">DateTimeZoneBuilder</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (15/ 15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.3%
  </span>
  <span class="absValue">
    (131/ 145)
  </span>
</td>
</tr>
  <tr>
    <td class="name">DateTimeZoneBuilder$DSTZone</td>
<td class="coverageStat">
  <span class="percent">
    90.9%
  </span>
  <span class="absValue">
    (10/ 11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    74.7%
  </span>
  <span class="absValue">
    (65/ 87)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeZoneBuilder$OfYear</td>
<td class="coverageStat">
  <span class="percent">
    91.7%
  </span>
  <span class="absValue">
    (11/ 12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80.2%
  </span>
  <span class="absValue">
    (97/ 121)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeZoneBuilder$PrecalculatedZone</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/ 12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.9%
  </span>
  <span class="absValue">
    (186/ 219)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeZoneBuilder$Recurrence</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (10/ 12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.6%
  </span>
  <span class="absValue">
    (22/ 26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeZoneBuilder$Rule</td>
<td class="coverageStat">
  <span class="percent">
    62.5%
  </span>
  <span class="absValue">
    (5/ 8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.5%
  </span>
  <span class="absValue">
    (23/ 26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeZoneBuilder$RuleSet</td>
<td class="coverageStat">
  <span class="percent">
    84.6%
  </span>
  <span class="absValue">
    (11/ 13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93%
  </span>
  <span class="absValue">
    (80/ 86)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DateTimeZoneBuilder$Transition</td>
<td class="coverageStat">
  <span class="percent">
    81.8%
  </span>
  <span class="absValue">
    (9/ 11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.1%
  </span>
  <span class="absValue">
    (27/ 29)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>total</strong></td>
<td class="coverageStat">
  <span class="percent">
    88.3%
  </span>
  <span class="absValue">
    (83/ 94)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.4%
  </span>
  <span class="absValue">
    (631/ 739)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<div class="sourceCode"><i>1</i>&nbsp;/*
<i>2</i>&nbsp; *  Copyright 2001-2013 Stephen Colebourne
<i>3</i>&nbsp; *
<i>4</i>&nbsp; *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
<i>5</i>&nbsp; *  you may not use this file except in compliance with the License.
<i>6</i>&nbsp; *  You may obtain a copy of the License at
<i>7</i>&nbsp; *
<i>8</i>&nbsp; *      http://www.apache.org/licenses/LICENSE-2.0
<i>9</i>&nbsp; *
<i>10</i>&nbsp; *  Unless required by applicable law or agreed to in writing, software
<i>11</i>&nbsp; *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
<i>12</i>&nbsp; *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<i>13</i>&nbsp; *  See the License for the specific language governing permissions and
<i>14</i>&nbsp; *  limitations under the License.
<i>15</i>&nbsp; */
<i>16</i>&nbsp;package org.joda.time.tz;
<i>17</i>&nbsp;
<i>18</i>&nbsp;import java.io.DataInput;
<i>19</i>&nbsp;import java.io.DataInputStream;
<i>20</i>&nbsp;import java.io.DataOutput;
<i>21</i>&nbsp;import java.io.DataOutputStream;
<i>22</i>&nbsp;import java.io.IOException;
<i>23</i>&nbsp;import java.io.InputStream;
<i>24</i>&nbsp;import java.io.OutputStream;
<i>25</i>&nbsp;import java.text.DateFormatSymbols;
<i>26</i>&nbsp;import java.util.ArrayList;
<i>27</i>&nbsp;import java.util.Arrays;
<i>28</i>&nbsp;import java.util.HashSet;
<i>29</i>&nbsp;import java.util.Iterator;
<i>30</i>&nbsp;import java.util.Locale;
<i>31</i>&nbsp;import java.util.Set;
<i>32</i>&nbsp;
<i>33</i>&nbsp;import org.joda.time.Chronology;
<i>34</i>&nbsp;import org.joda.time.DateTime;
<i>35</i>&nbsp;import org.joda.time.DateTimeUtils;
<i>36</i>&nbsp;import org.joda.time.DateTimeZone;
<i>37</i>&nbsp;import org.joda.time.Period;
<i>38</i>&nbsp;import org.joda.time.PeriodType;
<i>39</i>&nbsp;import org.joda.time.chrono.ISOChronology;
<i>40</i>&nbsp;
<i>41</i>&nbsp;/**
<i>42</i>&nbsp; * DateTimeZoneBuilder allows complex DateTimeZones to be constructed. Since
<i>43</i>&nbsp; * creating a new DateTimeZone this way is a relatively expensive operation,
<i>44</i>&nbsp; * built zones can be written to a file. Reading back the encoded data is a
<i>45</i>&nbsp; * quick operation.
<i>46</i>&nbsp; * &lt;p&gt;
<i>47</i>&nbsp; * DateTimeZoneBuilder itself is mutable and not thread-safe, but the
<i>48</i>&nbsp; * DateTimeZone objects that it builds are thread-safe and immutable.
<i>49</i>&nbsp; * &lt;p&gt;
<i>50</i>&nbsp; * It is intended that {@link ZoneInfoCompiler} be used to read time zone data
<i>51</i>&nbsp; * files, indirectly calling DateTimeZoneBuilder. The following complex
<i>52</i>&nbsp; * example defines the America/Los_Angeles time zone, with all historical
<i>53</i>&nbsp; * transitions:
<i>54</i>&nbsp; * 
<i>55</i>&nbsp; * &lt;pre&gt;
<i>56</i>&nbsp; * DateTimeZone America_Los_Angeles = new DateTimeZoneBuilder()
<i>57</i>&nbsp; *     .addCutover(-2147483648, &#39;w&#39;, 1, 1, 0, false, 0)
<i>58</i>&nbsp; *     .setStandardOffset(-28378000)
<i>59</i>&nbsp; *     .setFixedSavings(&quot;LMT&quot;, 0)
<i>60</i>&nbsp; *     .addCutover(1883, &#39;w&#39;, 11, 18, 0, false, 43200000)
<i>61</i>&nbsp; *     .setStandardOffset(-28800000)
<i>62</i>&nbsp; *     .addRecurringSavings(&quot;PDT&quot;, 3600000, 1918, 1919, &#39;w&#39;,  3, -1, 7, false, 7200000)
<i>63</i>&nbsp; *     .addRecurringSavings(&quot;PST&quot;,       0, 1918, 1919, &#39;w&#39;, 10, -1, 7, false, 7200000)
<i>64</i>&nbsp; *     .addRecurringSavings(&quot;PWT&quot;, 3600000, 1942, 1942, &#39;w&#39;,  2,  9, 0, false, 7200000)
<i>65</i>&nbsp; *     .addRecurringSavings(&quot;PPT&quot;, 3600000, 1945, 1945, &#39;u&#39;,  8, 14, 0, false, 82800000)
<i>66</i>&nbsp; *     .addRecurringSavings(&quot;PST&quot;,       0, 1945, 1945, &#39;w&#39;,  9, 30, 0, false, 7200000)
<i>67</i>&nbsp; *     .addRecurringSavings(&quot;PDT&quot;, 3600000, 1948, 1948, &#39;w&#39;,  3, 14, 0, false, 7200000)
<i>68</i>&nbsp; *     .addRecurringSavings(&quot;PST&quot;,       0, 1949, 1949, &#39;w&#39;,  1,  1, 0, false, 7200000)
<i>69</i>&nbsp; *     .addRecurringSavings(&quot;PDT&quot;, 3600000, 1950, 1966, &#39;w&#39;,  4, -1, 7, false, 7200000)
<i>70</i>&nbsp; *     .addRecurringSavings(&quot;PST&quot;,       0, 1950, 1961, &#39;w&#39;,  9, -1, 7, false, 7200000)
<i>71</i>&nbsp; *     .addRecurringSavings(&quot;PST&quot;,       0, 1962, 1966, &#39;w&#39;, 10, -1, 7, false, 7200000)
<i>72</i>&nbsp; *     .addRecurringSavings(&quot;PST&quot;,       0, 1967, 2147483647, &#39;w&#39;, 10, -1, 7, false, 7200000)
<i>73</i>&nbsp; *     .addRecurringSavings(&quot;PDT&quot;, 3600000, 1967, 1973, &#39;w&#39;, 4, -1,  7, false, 7200000)
<i>74</i>&nbsp; *     .addRecurringSavings(&quot;PDT&quot;, 3600000, 1974, 1974, &#39;w&#39;, 1,  6,  0, false, 7200000)
<i>75</i>&nbsp; *     .addRecurringSavings(&quot;PDT&quot;, 3600000, 1975, 1975, &#39;w&#39;, 2, 23,  0, false, 7200000)
<i>76</i>&nbsp; *     .addRecurringSavings(&quot;PDT&quot;, 3600000, 1976, 1986, &#39;w&#39;, 4, -1,  7, false, 7200000)
<i>77</i>&nbsp; *     .addRecurringSavings(&quot;PDT&quot;, 3600000, 1987, 2147483647, &#39;w&#39;, 4, 1, 7, true, 7200000)
<i>78</i>&nbsp; *     .toDateTimeZone(&quot;America/Los_Angeles&quot;, true);
<i>79</i>&nbsp; * &lt;/pre&gt;
<i>80</i>&nbsp; *
<i>81</i>&nbsp; * @author Brian S O&#39;Neill
<i>82</i>&nbsp; * @see ZoneInfoCompiler
<i>83</i>&nbsp; * @see ZoneInfoProvider
<i>84</i>&nbsp; * @since 1.0
<i>85</i>&nbsp; */
<i>86</i>&nbsp;public class DateTimeZoneBuilder {
<i>87</i>&nbsp;    /**
<i>88</i>&nbsp;     * Decodes a built DateTimeZone from the given stream, as encoded by
<i>89</i>&nbsp;     * writeTo.
<i>90</i>&nbsp;     *
<i>91</i>&nbsp;     * @param in input stream to read encoded DateTimeZone from.
<i>92</i>&nbsp;     * @param id time zone id to assign
<i>93</i>&nbsp;     */
<i>94</i>&nbsp;    public static DateTimeZone readFrom(InputStream in, String id) throws IOException {
<b class="fc"><i>95</i>&nbsp;        if (in instanceof DataInput) {</b>
<b class="nc"><i>96</i>&nbsp;            return readFrom((DataInput)in, id);</b>
<i>97</i>&nbsp;        } else {
<b class="fc"><i>98</i>&nbsp;            return readFrom((DataInput)new DataInputStream(in), id);</b>
<i>99</i>&nbsp;        }
<i>100</i>&nbsp;    }
<i>101</i>&nbsp;
<i>102</i>&nbsp;    /**
<i>103</i>&nbsp;     * Decodes a built DateTimeZone from the given stream, as encoded by
<i>104</i>&nbsp;     * writeTo.
<i>105</i>&nbsp;     *
<i>106</i>&nbsp;     * @param in input stream to read encoded DateTimeZone from.
<i>107</i>&nbsp;     * @param id time zone id to assign
<i>108</i>&nbsp;     */
<i>109</i>&nbsp;    public static DateTimeZone readFrom(DataInput in, String id) throws IOException {
<b class="fc"><i>110</i>&nbsp;        switch (in.readUnsignedByte()) {</b>
<i>111</i>&nbsp;        case &#39;F&#39;:
<b class="fc"><i>112</i>&nbsp;            DateTimeZone fixed = new FixedDateTimeZone</b>
<b class="fc"><i>113</i>&nbsp;                (id, in.readUTF(), (int)readMillis(in), (int)readMillis(in));</b>
<b class="fc"><i>114</i>&nbsp;            if (fixed.equals(DateTimeZone.UTC)) {</b>
<b class="nc"><i>115</i>&nbsp;                fixed = DateTimeZone.UTC;</b>
<i>116</i>&nbsp;            }
<b class="fc"><i>117</i>&nbsp;            return fixed;</b>
<i>118</i>&nbsp;        case &#39;C&#39;:
<b class="fc"><i>119</i>&nbsp;            return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id));</b>
<i>120</i>&nbsp;        case &#39;P&#39;:
<b class="fc"><i>121</i>&nbsp;            return PrecalculatedZone.readFrom(in, id);</b>
<i>122</i>&nbsp;        default:
<b class="nc"><i>123</i>&nbsp;            throw new IOException(&quot;Invalid encoding&quot;);</b>
<i>124</i>&nbsp;        }
<i>125</i>&nbsp;    }
<i>126</i>&nbsp;
<i>127</i>&nbsp;    /**
<i>128</i>&nbsp;     * Millisecond encoding formats:
<i>129</i>&nbsp;     *
<i>130</i>&nbsp;     * upper two bits  units       field length  approximate range
<i>131</i>&nbsp;     * ---------------------------------------------------------------
<i>132</i>&nbsp;     * 00              30 minutes  1 byte        +/- 16 hours
<i>133</i>&nbsp;     * 01              minutes     4 bytes       +/- 1020 years
<i>134</i>&nbsp;     * 10              seconds     5 bytes       +/- 4355 years
<i>135</i>&nbsp;     * 11              millis      9 bytes       +/- 292,000,000 years
<i>136</i>&nbsp;     *
<i>137</i>&nbsp;     * Remaining bits in field form signed offset from 1970-01-01T00:00:00Z.
<i>138</i>&nbsp;     */
<i>139</i>&nbsp;    static void writeMillis(DataOutput out, long millis) throws IOException {
<b class="fc"><i>140</i>&nbsp;        if (millis % (30 * 60000L) == 0) {</b>
<i>141</i>&nbsp;            // Try to write in 30 minute units.
<b class="fc"><i>142</i>&nbsp;            long units = millis / (30 * 60000L);</b>
<b class="fc"><i>143</i>&nbsp;            if (((units &lt;&lt; (64 - 6)) &gt;&gt; (64 - 6)) == units) {</b>
<i>144</i>&nbsp;                // Form 00 (6 bits effective precision)
<b class="fc"><i>145</i>&nbsp;                out.writeByte((int)(units &amp; 0x3f));</b>
<b class="fc"><i>146</i>&nbsp;                return;</b>
<i>147</i>&nbsp;            }
<i>148</i>&nbsp;        }
<i>149</i>&nbsp;
<b class="fc"><i>150</i>&nbsp;        if (millis % 60000L == 0) {</b>
<i>151</i>&nbsp;            // Try to write minutes.
<b class="fc"><i>152</i>&nbsp;            long minutes = millis / 60000L;</b>
<b class="fc"><i>153</i>&nbsp;            if (((minutes &lt;&lt; (64 - 30)) &gt;&gt; (64 - 30)) == minutes) {</b>
<i>154</i>&nbsp;                // Form 01 (30 bits effective precision)
<b class="fc"><i>155</i>&nbsp;                out.writeInt(0x40000000 | (int)(minutes &amp; 0x3fffffff));</b>
<b class="fc"><i>156</i>&nbsp;                return;</b>
<i>157</i>&nbsp;            }
<i>158</i>&nbsp;        }
<i>159</i>&nbsp;        
<b class="fc"><i>160</i>&nbsp;        if (millis % 1000L == 0) {</b>
<i>161</i>&nbsp;            // Try to write seconds.
<b class="fc"><i>162</i>&nbsp;            long seconds = millis / 1000L;</b>
<b class="fc"><i>163</i>&nbsp;            if (((seconds &lt;&lt; (64 - 38)) &gt;&gt; (64 - 38)) == seconds) {</b>
<i>164</i>&nbsp;                // Form 10 (38 bits effective precision)
<b class="fc"><i>165</i>&nbsp;                out.writeByte(0x80 | (int)((seconds &gt;&gt; 32) &amp; 0x3f));</b>
<b class="fc"><i>166</i>&nbsp;                out.writeInt((int)(seconds &amp; 0xffffffff));</b>
<b class="fc"><i>167</i>&nbsp;                return;</b>
<i>168</i>&nbsp;            }
<i>169</i>&nbsp;        }
<i>170</i>&nbsp;
<i>171</i>&nbsp;        // Write milliseconds either because the additional precision is
<i>172</i>&nbsp;        // required or the minutes didn&#39;t fit in the field.
<i>173</i>&nbsp;        
<i>174</i>&nbsp;        // Form 11 (64-bits effective precision, but write as if 70 bits)
<b class="fc"><i>175</i>&nbsp;        out.writeByte(millis &lt; 0 ? 0xff : 0xc0);</b>
<b class="fc"><i>176</i>&nbsp;        out.writeLong(millis);</b>
<b class="fc"><i>177</i>&nbsp;    }</b>
<i>178</i>&nbsp;
<i>179</i>&nbsp;    /**
<i>180</i>&nbsp;     * Reads encoding generated by writeMillis.
<i>181</i>&nbsp;     */
<i>182</i>&nbsp;    static long readMillis(DataInput in) throws IOException {
<b class="fc"><i>183</i>&nbsp;        int v = in.readUnsignedByte();</b>
<b class="fc"><i>184</i>&nbsp;        switch (v &gt;&gt; 6) {</b>
<i>185</i>&nbsp;        case 0: default:
<i>186</i>&nbsp;            // Form 00 (6 bits effective precision)
<b class="fc"><i>187</i>&nbsp;            v = (v &lt;&lt; (32 - 6)) &gt;&gt; (32 - 6);</b>
<b class="fc"><i>188</i>&nbsp;            return v * (30 * 60000L);</b>
<i>189</i>&nbsp;
<i>190</i>&nbsp;        case 1:
<i>191</i>&nbsp;            // Form 01 (30 bits effective precision)
<b class="fc"><i>192</i>&nbsp;            v = (v &lt;&lt; (32 - 6)) &gt;&gt; (32 - 30);</b>
<b class="fc"><i>193</i>&nbsp;            v |= (in.readUnsignedByte()) &lt;&lt; 16;</b>
<b class="fc"><i>194</i>&nbsp;            v |= (in.readUnsignedByte()) &lt;&lt; 8;</b>
<b class="fc"><i>195</i>&nbsp;            v |= (in.readUnsignedByte());</b>
<b class="fc"><i>196</i>&nbsp;            return v * 60000L;</b>
<i>197</i>&nbsp;
<i>198</i>&nbsp;        case 2:
<i>199</i>&nbsp;            // Form 10 (38 bits effective precision)
<b class="fc"><i>200</i>&nbsp;            long w = (((long)v) &lt;&lt; (64 - 6)) &gt;&gt; (64 - 38);</b>
<b class="fc"><i>201</i>&nbsp;            w |= (in.readUnsignedByte()) &lt;&lt; 24;</b>
<b class="fc"><i>202</i>&nbsp;            w |= (in.readUnsignedByte()) &lt;&lt; 16;</b>
<b class="fc"><i>203</i>&nbsp;            w |= (in.readUnsignedByte()) &lt;&lt; 8;</b>
<b class="fc"><i>204</i>&nbsp;            w |= (in.readUnsignedByte());</b>
<b class="fc"><i>205</i>&nbsp;            return w * 1000L;</b>
<i>206</i>&nbsp;
<i>207</i>&nbsp;        case 3:
<i>208</i>&nbsp;            // Form 11 (64-bits effective precision)
<b class="fc"><i>209</i>&nbsp;            return in.readLong();</b>
<i>210</i>&nbsp;        }
<i>211</i>&nbsp;    }
<i>212</i>&nbsp;
<i>213</i>&nbsp;    private static DateTimeZone buildFixedZone(String id, String nameKey,
<i>214</i>&nbsp;                                               int wallOffset, int standardOffset) {
<b class="fc"><i>215</i>&nbsp;        if (&quot;UTC&quot;.equals(id) &amp;&amp; id.equals(nameKey) &amp;&amp;</b>
<i>216</i>&nbsp;            wallOffset == 0 &amp;&amp; standardOffset == 0) {
<b class="nc"><i>217</i>&nbsp;            return DateTimeZone.UTC;</b>
<i>218</i>&nbsp;        }
<b class="fc"><i>219</i>&nbsp;        return new FixedDateTimeZone(id, nameKey, wallOffset, standardOffset);</b>
<i>220</i>&nbsp;    }
<i>221</i>&nbsp;
<i>222</i>&nbsp;    // List of RuleSets.
<i>223</i>&nbsp;    private final ArrayList&lt;RuleSet&gt; iRuleSets;
<i>224</i>&nbsp;
<b class="fc"><i>225</i>&nbsp;    public DateTimeZoneBuilder() {</b>
<b class="fc"><i>226</i>&nbsp;        iRuleSets = new ArrayList&lt;RuleSet&gt;(10);</b>
<b class="fc"><i>227</i>&nbsp;    }</b>
<i>228</i>&nbsp;
<i>229</i>&nbsp;    /**
<i>230</i>&nbsp;     * Adds a cutover for added rules. The standard offset at the cutover
<i>231</i>&nbsp;     * defaults to 0. Call setStandardOffset afterwards to change it.
<i>232</i>&nbsp;     *
<i>233</i>&nbsp;     * @param year  the year of cutover
<i>234</i>&nbsp;     * @param mode &#39;u&#39; - cutover is measured against UTC, &#39;w&#39; - against wall
<i>235</i>&nbsp;     *  offset, &#39;s&#39; - against standard offset
<i>236</i>&nbsp;     * @param monthOfYear  the month from 1 (January) to 12 (December)
<i>237</i>&nbsp;     * @param dayOfMonth  if negative, set to ((last day of month) - ~dayOfMonth).
<i>238</i>&nbsp;     *  For example, if -1, set to last day of month
<i>239</i>&nbsp;     * @param dayOfWeek  from 1 (Monday) to 7 (Sunday), if 0 then ignore
<i>240</i>&nbsp;     * @param advanceDayOfWeek  if dayOfMonth does not fall on dayOfWeek, advance to
<i>241</i>&nbsp;     *  dayOfWeek when true, retreat when false.
<i>242</i>&nbsp;     * @param millisOfDay  additional precision for specifying time of day of cutover
<i>243</i>&nbsp;     */
<i>244</i>&nbsp;    public DateTimeZoneBuilder addCutover(int year,
<i>245</i>&nbsp;                                          char mode,
<i>246</i>&nbsp;                                          int monthOfYear,
<i>247</i>&nbsp;                                          int dayOfMonth,
<i>248</i>&nbsp;                                          int dayOfWeek,
<i>249</i>&nbsp;                                          boolean advanceDayOfWeek,
<i>250</i>&nbsp;                                          int millisOfDay)
<i>251</i>&nbsp;    {
<b class="fc"><i>252</i>&nbsp;        if (iRuleSets.size() &gt; 0) {</b>
<b class="fc"><i>253</i>&nbsp;            OfYear ofYear = new OfYear</b>
<i>254</i>&nbsp;                (mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);
<b class="fc"><i>255</i>&nbsp;            RuleSet lastRuleSet = iRuleSets.get(iRuleSets.size() - 1);</b>
<b class="fc"><i>256</i>&nbsp;            lastRuleSet.setUpperLimit(year, ofYear);</b>
<i>257</i>&nbsp;        }
<b class="fc"><i>258</i>&nbsp;        iRuleSets.add(new RuleSet());</b>
<b class="fc"><i>259</i>&nbsp;        return this;</b>
<i>260</i>&nbsp;    }
<i>261</i>&nbsp;
<i>262</i>&nbsp;    /**
<i>263</i>&nbsp;     * Sets the standard offset to use for newly added rules until the next
<i>264</i>&nbsp;     * cutover is added.
<i>265</i>&nbsp;     * @param standardOffset  the standard offset in millis
<i>266</i>&nbsp;     */
<i>267</i>&nbsp;    public DateTimeZoneBuilder setStandardOffset(int standardOffset) {
<b class="fc"><i>268</i>&nbsp;        getLastRuleSet().setStandardOffset(standardOffset);</b>
<b class="fc"><i>269</i>&nbsp;        return this;</b>
<i>270</i>&nbsp;    }
<i>271</i>&nbsp;
<i>272</i>&nbsp;    /**
<i>273</i>&nbsp;     * Set a fixed savings rule at the cutover.
<i>274</i>&nbsp;     */
<i>275</i>&nbsp;    public DateTimeZoneBuilder setFixedSavings(String nameKey, int saveMillis) {
<b class="fc"><i>276</i>&nbsp;        getLastRuleSet().setFixedSavings(nameKey, saveMillis);</b>
<b class="fc"><i>277</i>&nbsp;        return this;</b>
<i>278</i>&nbsp;    }
<i>279</i>&nbsp;
<i>280</i>&nbsp;    /**
<i>281</i>&nbsp;     * Add a recurring daylight saving time rule.
<i>282</i>&nbsp;     *
<i>283</i>&nbsp;     * @param nameKey  the name key of new rule
<i>284</i>&nbsp;     * @param saveMillis  the milliseconds to add to standard offset
<i>285</i>&nbsp;     * @param fromYear  the first year that rule is in effect, MIN_VALUE indicates
<i>286</i>&nbsp;     * beginning of time
<i>287</i>&nbsp;     * @param toYear  the last year (inclusive) that rule is in effect, MAX_VALUE
<i>288</i>&nbsp;     *  indicates end of time
<i>289</i>&nbsp;     * @param mode  &#39;u&#39; - transitions are calculated against UTC, &#39;w&#39; -
<i>290</i>&nbsp;     *  transitions are calculated against wall offset, &#39;s&#39; - transitions are
<i>291</i>&nbsp;     *  calculated against standard offset
<i>292</i>&nbsp;     * @param monthOfYear  the month from 1 (January) to 12 (December)
<i>293</i>&nbsp;     * @param dayOfMonth  if negative, set to ((last day of month) - ~dayOfMonth).
<i>294</i>&nbsp;     *  For example, if -1, set to last day of month
<i>295</i>&nbsp;     * @param dayOfWeek  from 1 (Monday) to 7 (Sunday), if 0 then ignore
<i>296</i>&nbsp;     * @param advanceDayOfWeek  if dayOfMonth does not fall on dayOfWeek, advance to
<i>297</i>&nbsp;     *  dayOfWeek when true, retreat when false.
<i>298</i>&nbsp;     * @param millisOfDay  additional precision for specifying time of day of transitions
<i>299</i>&nbsp;     */
<i>300</i>&nbsp;    public DateTimeZoneBuilder addRecurringSavings(String nameKey, int saveMillis,
<i>301</i>&nbsp;                                                   int fromYear, int toYear,
<i>302</i>&nbsp;                                                   char mode,
<i>303</i>&nbsp;                                                   int monthOfYear,
<i>304</i>&nbsp;                                                   int dayOfMonth,
<i>305</i>&nbsp;                                                   int dayOfWeek,
<i>306</i>&nbsp;                                                   boolean advanceDayOfWeek,
<i>307</i>&nbsp;                                                   int millisOfDay)
<i>308</i>&nbsp;    {
<b class="fc"><i>309</i>&nbsp;        if (fromYear &lt;= toYear) {</b>
<b class="fc"><i>310</i>&nbsp;            OfYear ofYear = new OfYear</b>
<i>311</i>&nbsp;                (mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);
<b class="fc"><i>312</i>&nbsp;            Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis);</b>
<b class="fc"><i>313</i>&nbsp;            Rule rule = new Rule(recurrence, fromYear, toYear);</b>
<b class="fc"><i>314</i>&nbsp;            getLastRuleSet().addRule(rule);</b>
<i>315</i>&nbsp;        }
<b class="fc"><i>316</i>&nbsp;        return this;</b>
<i>317</i>&nbsp;    }
<i>318</i>&nbsp;
<i>319</i>&nbsp;    private RuleSet getLastRuleSet() {
<b class="fc"><i>320</i>&nbsp;        if (iRuleSets.size() == 0) {</b>
<b class="fc"><i>321</i>&nbsp;            addCutover(Integer.MIN_VALUE, &#39;w&#39;, 1, 1, 0, false, 0);</b>
<i>322</i>&nbsp;        }
<b class="fc"><i>323</i>&nbsp;        return iRuleSets.get(iRuleSets.size() - 1);</b>
<i>324</i>&nbsp;    }
<i>325</i>&nbsp;    
<i>326</i>&nbsp;    /**
<i>327</i>&nbsp;     * Processes all the rules and builds a DateTimeZone.
<i>328</i>&nbsp;     *
<i>329</i>&nbsp;     * @param id  time zone id to assign
<i>330</i>&nbsp;     * @param outputID  true if the zone id should be output
<i>331</i>&nbsp;     */
<i>332</i>&nbsp;    public DateTimeZone toDateTimeZone(String id, boolean outputID) {
<b class="fc"><i>333</i>&nbsp;        if (id == null) {</b>
<b class="nc"><i>334</i>&nbsp;            throw new IllegalArgumentException();</b>
<i>335</i>&nbsp;        }
<i>336</i>&nbsp;
<i>337</i>&nbsp;        // Discover where all the transitions occur and store the results in
<i>338</i>&nbsp;        // these lists.
<b class="fc"><i>339</i>&nbsp;        ArrayList&lt;Transition&gt; transitions = new ArrayList&lt;Transition&gt;();</b>
<i>340</i>&nbsp;
<i>341</i>&nbsp;        // Tail zone picks up remaining transitions in the form of an endless
<i>342</i>&nbsp;        // DST cycle.
<b class="fc"><i>343</i>&nbsp;        DSTZone tailZone = null;</b>
<i>344</i>&nbsp;
<b class="fc"><i>345</i>&nbsp;        long millis = Long.MIN_VALUE;</b>
<b class="fc"><i>346</i>&nbsp;        int saveMillis = 0;</b>
<i>347</i>&nbsp;            
<b class="fc"><i>348</i>&nbsp;        int ruleSetCount = iRuleSets.size();</b>
<b class="fc"><i>349</i>&nbsp;        for (int i=0; i&lt;ruleSetCount; i++) {</b>
<b class="fc"><i>350</i>&nbsp;            RuleSet rs = iRuleSets.get(i);</b>
<b class="fc"><i>351</i>&nbsp;            Transition next = rs.firstTransition(millis);</b>
<b class="fc"><i>352</i>&nbsp;            if (next == null) {</b>
<b class="nc"><i>353</i>&nbsp;                continue;</b>
<i>354</i>&nbsp;            }
<b class="fc"><i>355</i>&nbsp;            addTransition(transitions, next);</b>
<b class="fc"><i>356</i>&nbsp;            millis = next.getMillis();</b>
<b class="fc"><i>357</i>&nbsp;            saveMillis = next.getSaveMillis();</b>
<i>358</i>&nbsp;
<i>359</i>&nbsp;            // Copy it since we&#39;re going to destroy it.
<b class="fc"><i>360</i>&nbsp;            rs = new RuleSet(rs);</b>
<i>361</i>&nbsp;
<b class="fc"><i>362</i>&nbsp;            while ((next = rs.nextTransition(millis, saveMillis)) != null) {</b>
<b class="fc"><i>363</i>&nbsp;                if (addTransition(transitions, next) &amp;&amp; tailZone != null) {</b>
<i>364</i>&nbsp;                    // Got the extra transition before DSTZone.
<b class="fc"><i>365</i>&nbsp;                    break;</b>
<i>366</i>&nbsp;                }
<b class="fc"><i>367</i>&nbsp;                millis = next.getMillis();</b>
<b class="fc"><i>368</i>&nbsp;                saveMillis = next.getSaveMillis();</b>
<b class="fc"><i>369</i>&nbsp;                if (tailZone == null &amp;&amp; i == ruleSetCount - 1) {</b>
<b class="fc"><i>370</i>&nbsp;                    tailZone = rs.buildTailZone(id);</b>
<i>371</i>&nbsp;                    // If tailZone is not null, don&#39;t break out of main loop until
<i>372</i>&nbsp;                    // at least one more transition is calculated. This ensures a
<i>373</i>&nbsp;                    // correct &#39;seam&#39; to the DSTZone.
<i>374</i>&nbsp;                }
<i>375</i>&nbsp;            }
<i>376</i>&nbsp;
<b class="fc"><i>377</i>&nbsp;            millis = rs.getUpperLimit(saveMillis);</b>
<i>378</i>&nbsp;        }
<i>379</i>&nbsp;
<i>380</i>&nbsp;        // Check if a simpler zone implementation can be returned.
<b class="fc"><i>381</i>&nbsp;        if (transitions.size() == 0) {</b>
<b class="nc"><i>382</i>&nbsp;            if (tailZone != null) {</b>
<i>383</i>&nbsp;                // This shouldn&#39;t happen, but handle just in case.
<b class="nc"><i>384</i>&nbsp;                return tailZone;</b>
<i>385</i>&nbsp;            }
<b class="nc"><i>386</i>&nbsp;            return buildFixedZone(id, &quot;UTC&quot;, 0, 0);</b>
<i>387</i>&nbsp;        }
<b class="fc"><i>388</i>&nbsp;        if (transitions.size() == 1 &amp;&amp; tailZone == null) {</b>
<b class="fc"><i>389</i>&nbsp;            Transition tr = transitions.get(0);</b>
<b class="fc"><i>390</i>&nbsp;            return buildFixedZone(id, tr.getNameKey(),</b>
<b class="fc"><i>391</i>&nbsp;                                  tr.getWallOffset(), tr.getStandardOffset());</b>
<i>392</i>&nbsp;        }
<i>393</i>&nbsp;
<b class="fc"><i>394</i>&nbsp;        PrecalculatedZone zone = PrecalculatedZone.create(id, outputID, transitions, tailZone);</b>
<b class="fc"><i>395</i>&nbsp;        if (zone.isCachable()) {</b>
<b class="fc"><i>396</i>&nbsp;            return CachedDateTimeZone.forZone(zone);</b>
<i>397</i>&nbsp;        }
<b class="fc"><i>398</i>&nbsp;        return zone;</b>
<i>399</i>&nbsp;    }
<i>400</i>&nbsp;
<i>401</i>&nbsp;    private boolean addTransition(ArrayList&lt;Transition&gt; transitions, Transition tr) {
<b class="fc"><i>402</i>&nbsp;        int size = transitions.size();</b>
<b class="fc"><i>403</i>&nbsp;        if (size == 0) {</b>
<i>404</i>&nbsp;//            System.out.println(&quot;Adding   &quot; + tr);
<b class="fc"><i>405</i>&nbsp;            transitions.add(tr);</b>
<b class="fc"><i>406</i>&nbsp;            return true;</b>
<i>407</i>&nbsp;        }
<i>408</i>&nbsp;
<b class="fc"><i>409</i>&nbsp;        Transition last = transitions.get(size - 1);</b>
<b class="fc"><i>410</i>&nbsp;        if (!tr.isTransitionFrom(last)) {</b>
<i>411</i>&nbsp;//            System.out.println(&quot;Rejected &quot; + tr);
<b class="fc"><i>412</i>&nbsp;            return false;</b>
<i>413</i>&nbsp;        }
<i>414</i>&nbsp;
<i>415</i>&nbsp;        // If local time of new transition is same as last local time, just
<i>416</i>&nbsp;        // replace last transition with new one.
<b class="fc"><i>417</i>&nbsp;        int offsetForLast = 0;</b>
<b class="fc"><i>418</i>&nbsp;        if (size &gt;= 2) {</b>
<b class="fc"><i>419</i>&nbsp;            offsetForLast = transitions.get(size - 2).getWallOffset();</b>
<i>420</i>&nbsp;        }
<b class="fc"><i>421</i>&nbsp;        int offsetForNew = last.getWallOffset();</b>
<i>422</i>&nbsp;
<b class="fc"><i>423</i>&nbsp;        long lastLocal = last.getMillis() + offsetForLast;</b>
<b class="fc"><i>424</i>&nbsp;        long newLocal = tr.getMillis() + offsetForNew;</b>
<i>425</i>&nbsp;
<b class="fc"><i>426</i>&nbsp;        if (newLocal != lastLocal) {</b>
<b class="fc"><i>427</i>&nbsp;            transitions.add(tr);</b>
<i>428</i>&nbsp;//            System.out.println(&quot;Adding   &quot; + tr);
<b class="fc"><i>429</i>&nbsp;            return true;</b>
<i>430</i>&nbsp;        }
<b class="nc"><i>431</i>&nbsp;        Transition previous = transitions.remove(size - 1);</b>
<b class="nc"><i>432</i>&nbsp;        Transition adjusted = tr.withMillis(previous.getMillis());</b>
<i>433</i>&nbsp;//        System.out.println(&quot;Current  &quot; + tr);
<i>434</i>&nbsp;//        System.out.println(&quot;Previous &quot; + previous);
<i>435</i>&nbsp;//        System.out.println(&quot;Adjusted &quot; + adjusted);
<b class="nc"><i>436</i>&nbsp;        return addTransition(transitions, adjusted);</b>
<i>437</i>&nbsp;    }
<i>438</i>&nbsp;
<i>439</i>&nbsp;    /**
<i>440</i>&nbsp;     * Encodes a built DateTimeZone to the given stream. Call readFrom to
<i>441</i>&nbsp;     * decode the data into a DateTimeZone object.
<i>442</i>&nbsp;     *
<i>443</i>&nbsp;     * @param out  the output stream to receive the encoded DateTimeZone
<i>444</i>&nbsp;     * @since 1.5 (parameter added)
<i>445</i>&nbsp;     */
<i>446</i>&nbsp;    public void writeTo(String zoneID, OutputStream out) throws IOException {
<b class="fc"><i>447</i>&nbsp;        if (out instanceof DataOutput) {</b>
<b class="nc"><i>448</i>&nbsp;            writeTo(zoneID, (DataOutput)out);</b>
<i>449</i>&nbsp;        } else {
<b class="fc"><i>450</i>&nbsp;            DataOutputStream dout = new DataOutputStream(out);</b>
<b class="fc"><i>451</i>&nbsp;            writeTo(zoneID, (DataOutput)dout);</b>
<b class="fc"><i>452</i>&nbsp;            dout.flush();</b>
<i>453</i>&nbsp;        }
<b class="fc"><i>454</i>&nbsp;    }</b>
<i>455</i>&nbsp;
<i>456</i>&nbsp;    /**
<i>457</i>&nbsp;     * Encodes a built DateTimeZone to the given stream. Call readFrom to
<i>458</i>&nbsp;     * decode the data into a DateTimeZone object.
<i>459</i>&nbsp;     *
<i>460</i>&nbsp;     * @param out  the output stream to receive the encoded DateTimeZone
<i>461</i>&nbsp;     * @since 1.5 (parameter added)
<i>462</i>&nbsp;     */
<i>463</i>&nbsp;    public void writeTo(String zoneID, DataOutput out) throws IOException {
<i>464</i>&nbsp;        // pass false so zone id is not written out
<b class="fc"><i>465</i>&nbsp;        DateTimeZone zone = toDateTimeZone(zoneID, false);</b>
<i>466</i>&nbsp;
<b class="fc"><i>467</i>&nbsp;        if (zone instanceof FixedDateTimeZone) {</b>
<b class="fc"><i>468</i>&nbsp;            out.writeByte(&#39;F&#39;); // &#39;F&#39; for fixed</b>
<b class="fc"><i>469</i>&nbsp;            out.writeUTF(zone.getNameKey(0));</b>
<b class="fc"><i>470</i>&nbsp;            writeMillis(out, zone.getOffset(0));</b>
<b class="fc"><i>471</i>&nbsp;            writeMillis(out, zone.getStandardOffset(0));</b>
<i>472</i>&nbsp;        } else {
<b class="fc"><i>473</i>&nbsp;            if (zone instanceof CachedDateTimeZone) {</b>
<b class="fc"><i>474</i>&nbsp;                out.writeByte(&#39;C&#39;); // &#39;C&#39; for cached, precalculated</b>
<b class="fc"><i>475</i>&nbsp;                zone = ((CachedDateTimeZone)zone).getUncachedZone();</b>
<i>476</i>&nbsp;            } else {
<b class="nc"><i>477</i>&nbsp;                out.writeByte(&#39;P&#39;); // &#39;P&#39; for precalculated, uncached</b>
<i>478</i>&nbsp;            }
<b class="fc"><i>479</i>&nbsp;            ((PrecalculatedZone)zone).writeTo(out);</b>
<i>480</i>&nbsp;        }
<b class="fc"><i>481</i>&nbsp;    }</b>
<i>482</i>&nbsp;
<i>483</i>&nbsp;    /**
<i>484</i>&nbsp;     * Supports setting fields of year and moving between transitions.
<i>485</i>&nbsp;     */
<i>486</i>&nbsp;    private static final class OfYear {
<i>487</i>&nbsp;        static OfYear readFrom(DataInput in) throws IOException {
<b class="fc"><i>488</i>&nbsp;            return new OfYear((char)in.readUnsignedByte(),</b>
<b class="fc"><i>489</i>&nbsp;                              (int)in.readUnsignedByte(),</b>
<b class="fc"><i>490</i>&nbsp;                              (int)in.readByte(),</b>
<b class="fc"><i>491</i>&nbsp;                              (int)in.readUnsignedByte(),</b>
<b class="fc"><i>492</i>&nbsp;                              in.readBoolean(),</b>
<b class="fc"><i>493</i>&nbsp;                              (int)readMillis(in));</b>
<i>494</i>&nbsp;        }
<i>495</i>&nbsp;
<i>496</i>&nbsp;        // Is &#39;u&#39;, &#39;w&#39;, or &#39;s&#39;.
<i>497</i>&nbsp;        final char iMode;
<i>498</i>&nbsp;
<i>499</i>&nbsp;        final int iMonthOfYear;
<i>500</i>&nbsp;        final int iDayOfMonth;
<i>501</i>&nbsp;        final int iDayOfWeek;
<i>502</i>&nbsp;        final boolean iAdvance;
<i>503</i>&nbsp;        final int iMillisOfDay;
<i>504</i>&nbsp;
<i>505</i>&nbsp;        OfYear(char mode,
<i>506</i>&nbsp;               int monthOfYear,
<i>507</i>&nbsp;               int dayOfMonth,
<i>508</i>&nbsp;               int dayOfWeek, boolean advanceDayOfWeek,
<i>509</i>&nbsp;               int millisOfDay)
<b class="fc"><i>510</i>&nbsp;        {</b>
<b class="fc"><i>511</i>&nbsp;            if (mode != &#39;u&#39; &amp;&amp; mode != &#39;w&#39; &amp;&amp; mode != &#39;s&#39;) {</b>
<b class="nc"><i>512</i>&nbsp;                throw new IllegalArgumentException(&quot;Unknown mode: &quot; + mode);</b>
<i>513</i>&nbsp;            }
<i>514</i>&nbsp;
<b class="fc"><i>515</i>&nbsp;            iMode = mode;</b>
<b class="fc"><i>516</i>&nbsp;            iMonthOfYear = monthOfYear;</b>
<b class="fc"><i>517</i>&nbsp;            iDayOfMonth = dayOfMonth;</b>
<b class="fc"><i>518</i>&nbsp;            iDayOfWeek = dayOfWeek;</b>
<b class="fc"><i>519</i>&nbsp;            iAdvance = advanceDayOfWeek;</b>
<b class="fc"><i>520</i>&nbsp;            iMillisOfDay = millisOfDay;</b>
<b class="fc"><i>521</i>&nbsp;        }</b>
<i>522</i>&nbsp;
<i>523</i>&nbsp;        /**
<i>524</i>&nbsp;         * @param standardOffset standard offset just before instant
<i>525</i>&nbsp;         */
<i>526</i>&nbsp;        public long setInstant(int year, int standardOffset, int saveMillis) {
<i>527</i>&nbsp;            int offset;
<b class="fc"><i>528</i>&nbsp;            if (iMode == &#39;w&#39;) {</b>
<b class="fc"><i>529</i>&nbsp;                offset = standardOffset + saveMillis;</b>
<b class="nc"><i>530</i>&nbsp;            } else if (iMode == &#39;s&#39;) {</b>
<b class="nc"><i>531</i>&nbsp;                offset = standardOffset;</b>
<i>532</i>&nbsp;            } else {
<b class="nc"><i>533</i>&nbsp;                offset = 0;</b>
<i>534</i>&nbsp;            }
<i>535</i>&nbsp;
<b class="fc"><i>536</i>&nbsp;            Chronology chrono = ISOChronology.getInstanceUTC();</b>
<b class="fc"><i>537</i>&nbsp;            long millis = chrono.year().set(0, year);</b>
<b class="fc"><i>538</i>&nbsp;            millis = chrono.monthOfYear().set(millis, iMonthOfYear);</b>
<b class="fc"><i>539</i>&nbsp;            millis = chrono.millisOfDay().set(millis, iMillisOfDay);</b>
<b class="fc"><i>540</i>&nbsp;            millis = setDayOfMonth(chrono, millis);</b>
<i>541</i>&nbsp;
<b class="fc"><i>542</i>&nbsp;            if (iDayOfWeek != 0) {</b>
<b class="nc"><i>543</i>&nbsp;                millis = setDayOfWeek(chrono, millis);</b>
<i>544</i>&nbsp;            }
<i>545</i>&nbsp;
<i>546</i>&nbsp;            // Convert from local time to UTC.
<b class="fc"><i>547</i>&nbsp;            return millis - offset;</b>
<i>548</i>&nbsp;        }
<i>549</i>&nbsp;
<i>550</i>&nbsp;        /**
<i>551</i>&nbsp;         * @param standardOffset standard offset just before next recurrence
<i>552</i>&nbsp;         */
<i>553</i>&nbsp;        public long next(long instant, int standardOffset, int saveMillis) {
<i>554</i>&nbsp;            int offset;
<b class="fc"><i>555</i>&nbsp;            if (iMode == &#39;w&#39;) {</b>
<b class="fc"><i>556</i>&nbsp;                offset = standardOffset + saveMillis;</b>
<b class="fc"><i>557</i>&nbsp;            } else if (iMode == &#39;s&#39;) {</b>
<b class="fc"><i>558</i>&nbsp;                offset = standardOffset;</b>
<i>559</i>&nbsp;            } else {
<b class="fc"><i>560</i>&nbsp;                offset = 0;</b>
<i>561</i>&nbsp;            }
<i>562</i>&nbsp;
<i>563</i>&nbsp;            // Convert from UTC to local time.
<b class="fc"><i>564</i>&nbsp;            instant += offset;</b>
<i>565</i>&nbsp;
<b class="fc"><i>566</i>&nbsp;            Chronology chrono = ISOChronology.getInstanceUTC();</b>
<b class="fc"><i>567</i>&nbsp;            long next = chrono.monthOfYear().set(instant, iMonthOfYear);</b>
<i>568</i>&nbsp;            // Be lenient with millisOfDay.
<b class="fc"><i>569</i>&nbsp;            next = chrono.millisOfDay().set(next, 0);</b>
<b class="fc"><i>570</i>&nbsp;            next = chrono.millisOfDay().add(next, iMillisOfDay);</b>
<b class="fc"><i>571</i>&nbsp;            next = setDayOfMonthNext(chrono, next);</b>
<i>572</i>&nbsp;
<b class="fc"><i>573</i>&nbsp;            if (iDayOfWeek == 0) {</b>
<b class="fc"><i>574</i>&nbsp;                if (next &lt;= instant) {</b>
<b class="fc"><i>575</i>&nbsp;                    next = chrono.year().add(next, 1);</b>
<b class="fc"><i>576</i>&nbsp;                    next = setDayOfMonthNext(chrono, next);</b>
<i>577</i>&nbsp;                }
<i>578</i>&nbsp;            } else {
<b class="fc"><i>579</i>&nbsp;                next = setDayOfWeek(chrono, next);</b>
<b class="fc"><i>580</i>&nbsp;                if (next &lt;= instant) {</b>
<b class="fc"><i>581</i>&nbsp;                    next = chrono.year().add(next, 1);</b>
<b class="fc"><i>582</i>&nbsp;                    next = chrono.monthOfYear().set(next, iMonthOfYear);</b>
<b class="fc"><i>583</i>&nbsp;                    next = setDayOfMonthNext(chrono, next);</b>
<b class="fc"><i>584</i>&nbsp;                    next = setDayOfWeek(chrono, next);</b>
<i>585</i>&nbsp;                }
<i>586</i>&nbsp;            }
<i>587</i>&nbsp;
<i>588</i>&nbsp;            // Convert from local time to UTC.
<b class="fc"><i>589</i>&nbsp;            return next - offset;</b>
<i>590</i>&nbsp;        }
<i>591</i>&nbsp;
<i>592</i>&nbsp;        /**
<i>593</i>&nbsp;         * @param standardOffset standard offset just before previous recurrence
<i>594</i>&nbsp;         */
<i>595</i>&nbsp;        public long previous(long instant, int standardOffset, int saveMillis) {
<i>596</i>&nbsp;            int offset;
<b class="fc"><i>597</i>&nbsp;            if (iMode == &#39;w&#39;) {</b>
<b class="fc"><i>598</i>&nbsp;                offset = standardOffset + saveMillis;</b>
<b class="fc"><i>599</i>&nbsp;            } else if (iMode == &#39;s&#39;) {</b>
<b class="fc"><i>600</i>&nbsp;                offset = standardOffset;</b>
<i>601</i>&nbsp;            } else {
<b class="fc"><i>602</i>&nbsp;                offset = 0;</b>
<i>603</i>&nbsp;            }
<i>604</i>&nbsp;
<i>605</i>&nbsp;            // Convert from UTC to local time.
<b class="fc"><i>606</i>&nbsp;            instant += offset;</b>
<i>607</i>&nbsp;
<b class="fc"><i>608</i>&nbsp;            Chronology chrono = ISOChronology.getInstanceUTC();</b>
<b class="fc"><i>609</i>&nbsp;            long prev = chrono.monthOfYear().set(instant, iMonthOfYear);</b>
<i>610</i>&nbsp;            // Be lenient with millisOfDay.
<b class="fc"><i>611</i>&nbsp;            prev = chrono.millisOfDay().set(prev, 0);</b>
<b class="fc"><i>612</i>&nbsp;            prev = chrono.millisOfDay().add(prev, iMillisOfDay);</b>
<b class="fc"><i>613</i>&nbsp;            prev = setDayOfMonthPrevious(chrono, prev);</b>
<i>614</i>&nbsp;
<b class="fc"><i>615</i>&nbsp;            if (iDayOfWeek == 0) {</b>
<b class="nc"><i>616</i>&nbsp;                if (prev &gt;= instant) {</b>
<b class="nc"><i>617</i>&nbsp;                    prev = chrono.year().add(prev, -1);</b>
<b class="nc"><i>618</i>&nbsp;                    prev = setDayOfMonthPrevious(chrono, prev);</b>
<i>619</i>&nbsp;                }
<i>620</i>&nbsp;            } else {
<b class="fc"><i>621</i>&nbsp;                prev = setDayOfWeek(chrono, prev);</b>
<b class="fc"><i>622</i>&nbsp;                if (prev &gt;= instant) {</b>
<b class="fc"><i>623</i>&nbsp;                    prev = chrono.year().add(prev, -1);</b>
<b class="fc"><i>624</i>&nbsp;                    prev = chrono.monthOfYear().set(prev, iMonthOfYear);</b>
<b class="fc"><i>625</i>&nbsp;                    prev = setDayOfMonthPrevious(chrono, prev);</b>
<b class="fc"><i>626</i>&nbsp;                    prev = setDayOfWeek(chrono, prev);</b>
<i>627</i>&nbsp;                }
<i>628</i>&nbsp;            }
<i>629</i>&nbsp;
<i>630</i>&nbsp;            // Convert from local time to UTC.
<b class="fc"><i>631</i>&nbsp;            return prev - offset;</b>
<i>632</i>&nbsp;        }
<i>633</i>&nbsp;
<i>634</i>&nbsp;        public boolean equals(Object obj) {
<b class="fc"><i>635</i>&nbsp;            if (this == obj) {</b>
<b class="nc"><i>636</i>&nbsp;                return true;</b>
<i>637</i>&nbsp;            }
<b class="fc"><i>638</i>&nbsp;            if (obj instanceof OfYear) {</b>
<b class="fc"><i>639</i>&nbsp;                OfYear other = (OfYear)obj;</b>
<b class="fc"><i>640</i>&nbsp;                return</b>
<i>641</i>&nbsp;                    iMode == other.iMode &amp;&amp;
<i>642</i>&nbsp;                    iMonthOfYear == other.iMonthOfYear &amp;&amp;
<i>643</i>&nbsp;                    iDayOfMonth == other.iDayOfMonth &amp;&amp;
<i>644</i>&nbsp;                    iDayOfWeek == other.iDayOfWeek &amp;&amp;
<i>645</i>&nbsp;                    iAdvance == other.iAdvance &amp;&amp;
<i>646</i>&nbsp;                    iMillisOfDay == other.iMillisOfDay;
<i>647</i>&nbsp;            }
<b class="nc"><i>648</i>&nbsp;            return false;</b>
<i>649</i>&nbsp;        }
<i>650</i>&nbsp;
<i>651</i>&nbsp;        public String toString() {
<b class="nc"><i>652</i>&nbsp;            return</b>
<i>653</i>&nbsp;                &quot;[OfYear]\n&quot; + 
<i>654</i>&nbsp;                &quot;Mode: &quot; + iMode + &#39;\n&#39; +
<i>655</i>&nbsp;                &quot;MonthOfYear: &quot; + iMonthOfYear + &#39;\n&#39; +
<i>656</i>&nbsp;                &quot;DayOfMonth: &quot; + iDayOfMonth + &#39;\n&#39; +
<i>657</i>&nbsp;                &quot;DayOfWeek: &quot; + iDayOfWeek + &#39;\n&#39; +
<i>658</i>&nbsp;                &quot;AdvanceDayOfWeek: &quot; + iAdvance + &#39;\n&#39; +
<i>659</i>&nbsp;                &quot;MillisOfDay: &quot; + iMillisOfDay + &#39;\n&#39;;
<i>660</i>&nbsp;        }
<i>661</i>&nbsp;
<i>662</i>&nbsp;        public void writeTo(DataOutput out) throws IOException {
<b class="fc"><i>663</i>&nbsp;            out.writeByte(iMode);</b>
<b class="fc"><i>664</i>&nbsp;            out.writeByte(iMonthOfYear);</b>
<b class="fc"><i>665</i>&nbsp;            out.writeByte(iDayOfMonth);</b>
<b class="fc"><i>666</i>&nbsp;            out.writeByte(iDayOfWeek);</b>
<b class="fc"><i>667</i>&nbsp;            out.writeBoolean(iAdvance);</b>
<b class="fc"><i>668</i>&nbsp;            writeMillis(out, iMillisOfDay);</b>
<b class="fc"><i>669</i>&nbsp;        }</b>
<i>670</i>&nbsp;
<i>671</i>&nbsp;        /**
<i>672</i>&nbsp;         * If month-day is 02-29 and year isn&#39;t leap, advances to next leap year.
<i>673</i>&nbsp;         */
<i>674</i>&nbsp;        private long setDayOfMonthNext(Chronology chrono, long next) {
<i>675</i>&nbsp;            try {
<b class="fc"><i>676</i>&nbsp;                next = setDayOfMonth(chrono, next);</b>
<b class="nc"><i>677</i>&nbsp;            } catch (IllegalArgumentException e) {</b>
<b class="nc"><i>678</i>&nbsp;                if (iMonthOfYear == 2 &amp;&amp; iDayOfMonth == 29) {</b>
<b class="nc"><i>679</i>&nbsp;                    while (chrono.year().isLeap(next) == false) {</b>
<b class="nc"><i>680</i>&nbsp;                        next = chrono.year().add(next, 1);</b>
<i>681</i>&nbsp;                    }
<b class="nc"><i>682</i>&nbsp;                    next = setDayOfMonth(chrono, next);</b>
<i>683</i>&nbsp;                } else {
<b class="nc"><i>684</i>&nbsp;                    throw e;</b>
<i>685</i>&nbsp;                }
<b class="fc"><i>686</i>&nbsp;            }</b>
<b class="fc"><i>687</i>&nbsp;            return next;</b>
<i>688</i>&nbsp;        }
<i>689</i>&nbsp;
<i>690</i>&nbsp;        /**
<i>691</i>&nbsp;         * If month-day is 02-29 and year isn&#39;t leap, retreats to previous leap year.
<i>692</i>&nbsp;         */
<i>693</i>&nbsp;        private long setDayOfMonthPrevious(Chronology chrono, long prev) {
<i>694</i>&nbsp;            try {
<b class="fc"><i>695</i>&nbsp;                prev = setDayOfMonth(chrono, prev);</b>
<b class="nc"><i>696</i>&nbsp;            } catch (IllegalArgumentException e) {</b>
<b class="nc"><i>697</i>&nbsp;                if (iMonthOfYear == 2 &amp;&amp; iDayOfMonth == 29) {</b>
<b class="nc"><i>698</i>&nbsp;                    while (chrono.year().isLeap(prev) == false) {</b>
<b class="nc"><i>699</i>&nbsp;                        prev = chrono.year().add(prev, -1);</b>
<i>700</i>&nbsp;                    }
<b class="nc"><i>701</i>&nbsp;                    prev = setDayOfMonth(chrono, prev);</b>
<i>702</i>&nbsp;                } else {
<b class="nc"><i>703</i>&nbsp;                    throw e;</b>
<i>704</i>&nbsp;                }
<b class="fc"><i>705</i>&nbsp;            }</b>
<b class="fc"><i>706</i>&nbsp;            return prev;</b>
<i>707</i>&nbsp;        }
<i>708</i>&nbsp;
<i>709</i>&nbsp;        private long setDayOfMonth(Chronology chrono, long instant) {
<b class="fc"><i>710</i>&nbsp;            if (iDayOfMonth &gt;= 0) {</b>
<b class="fc"><i>711</i>&nbsp;                instant = chrono.dayOfMonth().set(instant, iDayOfMonth);</b>
<i>712</i>&nbsp;            } else {
<b class="fc"><i>713</i>&nbsp;                instant = chrono.dayOfMonth().set(instant, 1);</b>
<b class="fc"><i>714</i>&nbsp;                instant = chrono.monthOfYear().add(instant, 1);</b>
<b class="fc"><i>715</i>&nbsp;                instant = chrono.dayOfMonth().add(instant, iDayOfMonth);</b>
<i>716</i>&nbsp;            }
<b class="fc"><i>717</i>&nbsp;            return instant;</b>
<i>718</i>&nbsp;        }
<i>719</i>&nbsp;
<i>720</i>&nbsp;        private long setDayOfWeek(Chronology chrono, long instant) {
<b class="fc"><i>721</i>&nbsp;            int dayOfWeek = chrono.dayOfWeek().get(instant);</b>
<b class="fc"><i>722</i>&nbsp;            int daysToAdd = iDayOfWeek - dayOfWeek;</b>
<b class="fc"><i>723</i>&nbsp;            if (daysToAdd != 0) {</b>
<b class="fc"><i>724</i>&nbsp;                if (iAdvance) {</b>
<b class="fc"><i>725</i>&nbsp;                    if (daysToAdd &lt; 0) {</b>
<b class="nc"><i>726</i>&nbsp;                        daysToAdd += 7;</b>
<i>727</i>&nbsp;                    }
<i>728</i>&nbsp;                } else {
<b class="fc"><i>729</i>&nbsp;                    if (daysToAdd &gt; 0) {</b>
<b class="fc"><i>730</i>&nbsp;                        daysToAdd -= 7;</b>
<i>731</i>&nbsp;                    }
<i>732</i>&nbsp;                }
<b class="fc"><i>733</i>&nbsp;                instant = chrono.dayOfWeek().add(instant, daysToAdd);</b>
<i>734</i>&nbsp;            }
<b class="fc"><i>735</i>&nbsp;            return instant;</b>
<i>736</i>&nbsp;        }
<i>737</i>&nbsp;    }
<i>738</i>&nbsp;
<i>739</i>&nbsp;    /**
<i>740</i>&nbsp;     * Extends OfYear with a nameKey and savings.
<i>741</i>&nbsp;     */
<i>742</i>&nbsp;    private static final class Recurrence {
<i>743</i>&nbsp;        static Recurrence readFrom(DataInput in) throws IOException {
<b class="fc"><i>744</i>&nbsp;            return new Recurrence(OfYear.readFrom(in), in.readUTF(), (int)readMillis(in));</b>
<i>745</i>&nbsp;        }
<i>746</i>&nbsp;
<i>747</i>&nbsp;        final OfYear iOfYear;
<i>748</i>&nbsp;        final String iNameKey;
<i>749</i>&nbsp;        final int iSaveMillis;
<i>750</i>&nbsp;
<b class="fc"><i>751</i>&nbsp;        Recurrence(OfYear ofYear, String nameKey, int saveMillis) {</b>
<b class="fc"><i>752</i>&nbsp;            iOfYear = ofYear;</b>
<b class="fc"><i>753</i>&nbsp;            iNameKey = nameKey;</b>
<b class="fc"><i>754</i>&nbsp;            iSaveMillis = saveMillis;</b>
<b class="fc"><i>755</i>&nbsp;        }</b>
<i>756</i>&nbsp;
<i>757</i>&nbsp;        public OfYear getOfYear() {
<b class="nc"><i>758</i>&nbsp;            return iOfYear;</b>
<i>759</i>&nbsp;        }
<i>760</i>&nbsp;
<i>761</i>&nbsp;        /**
<i>762</i>&nbsp;         * @param standardOffset standard offset just before next recurrence
<i>763</i>&nbsp;         */
<i>764</i>&nbsp;        public long next(long instant, int standardOffset, int saveMillis) {
<b class="fc"><i>765</i>&nbsp;            return iOfYear.next(instant, standardOffset, saveMillis);</b>
<i>766</i>&nbsp;        }
<i>767</i>&nbsp;
<i>768</i>&nbsp;        /**
<i>769</i>&nbsp;         * @param standardOffset standard offset just before previous recurrence
<i>770</i>&nbsp;         */
<i>771</i>&nbsp;        public long previous(long instant, int standardOffset, int saveMillis) {
<b class="fc"><i>772</i>&nbsp;            return iOfYear.previous(instant, standardOffset, saveMillis);</b>
<i>773</i>&nbsp;        }
<i>774</i>&nbsp;
<i>775</i>&nbsp;        public String getNameKey() {
<b class="fc"><i>776</i>&nbsp;            return iNameKey;</b>
<i>777</i>&nbsp;        }
<i>778</i>&nbsp;
<i>779</i>&nbsp;        public int getSaveMillis() {
<b class="fc"><i>780</i>&nbsp;            return iSaveMillis;</b>
<i>781</i>&nbsp;        }
<i>782</i>&nbsp;
<i>783</i>&nbsp;        public boolean equals(Object obj) {
<b class="fc"><i>784</i>&nbsp;            if (this == obj) {</b>
<b class="nc"><i>785</i>&nbsp;                return true;</b>
<i>786</i>&nbsp;            }
<b class="fc"><i>787</i>&nbsp;            if (obj instanceof Recurrence) {</b>
<b class="fc"><i>788</i>&nbsp;                Recurrence other = (Recurrence)obj;</b>
<b class="fc"><i>789</i>&nbsp;                return</b>
<i>790</i>&nbsp;                    iSaveMillis == other.iSaveMillis &amp;&amp;
<b class="fc"><i>791</i>&nbsp;                    iNameKey.equals(other.iNameKey) &amp;&amp;</b>
<b class="fc"><i>792</i>&nbsp;                    iOfYear.equals(other.iOfYear);</b>
<i>793</i>&nbsp;            }
<b class="nc"><i>794</i>&nbsp;            return false;</b>
<i>795</i>&nbsp;        }
<i>796</i>&nbsp;
<i>797</i>&nbsp;        public void writeTo(DataOutput out) throws IOException {
<b class="fc"><i>798</i>&nbsp;            iOfYear.writeTo(out);</b>
<b class="fc"><i>799</i>&nbsp;            out.writeUTF(iNameKey);</b>
<b class="fc"><i>800</i>&nbsp;            writeMillis(out, iSaveMillis);</b>
<b class="fc"><i>801</i>&nbsp;        }</b>
<i>802</i>&nbsp;
<i>803</i>&nbsp;        Recurrence rename(String nameKey) {
<b class="fc"><i>804</i>&nbsp;            return new Recurrence(iOfYear, nameKey, iSaveMillis);</b>
<i>805</i>&nbsp;        }
<i>806</i>&nbsp;
<i>807</i>&nbsp;        Recurrence renameAppend(String appendNameKey) {
<b class="fc"><i>808</i>&nbsp;            return rename((iNameKey + appendNameKey).intern());</b>
<i>809</i>&nbsp;        }
<i>810</i>&nbsp;        
<i>811</i>&nbsp;        @Override
<i>812</i>&nbsp;        public String toString() {
<b class="nc"><i>813</i>&nbsp;            return iOfYear + &quot; named &quot; + iNameKey + &quot; at &quot; + iSaveMillis;</b>
<i>814</i>&nbsp;        }
<i>815</i>&nbsp;    }
<i>816</i>&nbsp;
<i>817</i>&nbsp;    /**
<i>818</i>&nbsp;     * Extends Recurrence with inclusive year limits.
<i>819</i>&nbsp;     */
<i>820</i>&nbsp;    private static final class Rule {
<i>821</i>&nbsp;        final Recurrence iRecurrence;
<i>822</i>&nbsp;        final int iFromYear; // inclusive
<i>823</i>&nbsp;        final int iToYear;   // inclusive
<i>824</i>&nbsp;
<b class="fc"><i>825</i>&nbsp;        Rule(Recurrence recurrence, int fromYear, int toYear) {</b>
<b class="fc"><i>826</i>&nbsp;            iRecurrence = recurrence;</b>
<b class="fc"><i>827</i>&nbsp;            iFromYear = fromYear;</b>
<b class="fc"><i>828</i>&nbsp;            iToYear = toYear;</b>
<b class="fc"><i>829</i>&nbsp;        }</b>
<i>830</i>&nbsp;
<i>831</i>&nbsp;        @SuppressWarnings(&quot;unused&quot;)
<i>832</i>&nbsp;        public int getFromYear() {
<b class="nc"><i>833</i>&nbsp;            return iFromYear;</b>
<i>834</i>&nbsp;        }
<i>835</i>&nbsp;
<i>836</i>&nbsp;        public int getToYear() {
<b class="fc"><i>837</i>&nbsp;            return iToYear;</b>
<i>838</i>&nbsp;        }
<i>839</i>&nbsp;
<i>840</i>&nbsp;        @SuppressWarnings(&quot;unused&quot;)
<i>841</i>&nbsp;        public OfYear getOfYear() {
<b class="nc"><i>842</i>&nbsp;            return iRecurrence.getOfYear();</b>
<i>843</i>&nbsp;        }
<i>844</i>&nbsp;
<i>845</i>&nbsp;        public String getNameKey() {
<b class="fc"><i>846</i>&nbsp;            return iRecurrence.getNameKey();</b>
<i>847</i>&nbsp;        }
<i>848</i>&nbsp;
<i>849</i>&nbsp;        public int getSaveMillis() {
<b class="fc"><i>850</i>&nbsp;            return iRecurrence.getSaveMillis();</b>
<i>851</i>&nbsp;        }
<i>852</i>&nbsp;
<i>853</i>&nbsp;        public long next(final long instant, int standardOffset, int saveMillis) {
<b class="fc"><i>854</i>&nbsp;            Chronology chrono = ISOChronology.getInstanceUTC();</b>
<i>855</i>&nbsp;
<b class="fc"><i>856</i>&nbsp;            final int wallOffset = standardOffset + saveMillis;</b>
<b class="fc"><i>857</i>&nbsp;            long testInstant = instant;</b>
<i>858</i>&nbsp;
<i>859</i>&nbsp;            int year;
<b class="fc"><i>860</i>&nbsp;            if (instant == Long.MIN_VALUE) {</b>
<b class="fc"><i>861</i>&nbsp;                year = Integer.MIN_VALUE;</b>
<i>862</i>&nbsp;            } else {
<b class="fc"><i>863</i>&nbsp;                year = chrono.year().get(instant + wallOffset);</b>
<i>864</i>&nbsp;            }
<i>865</i>&nbsp;
<b class="fc"><i>866</i>&nbsp;            if (year &lt; iFromYear) {</b>
<i>867</i>&nbsp;                // First advance instant to start of from year.
<b class="fc"><i>868</i>&nbsp;                testInstant = chrono.year().set(0, iFromYear) - wallOffset;</b>
<i>869</i>&nbsp;                // Back off one millisecond to account for next recurrence
<i>870</i>&nbsp;                // being exactly at the beginning of the year.
<b class="fc"><i>871</i>&nbsp;                testInstant -= 1;</b>
<i>872</i>&nbsp;            }
<i>873</i>&nbsp;
<b class="fc"><i>874</i>&nbsp;            long next = iRecurrence.next(testInstant, standardOffset, saveMillis);</b>
<i>875</i>&nbsp;
<b class="fc"><i>876</i>&nbsp;            if (next &gt; instant) {</b>
<b class="fc"><i>877</i>&nbsp;                year = chrono.year().get(next + wallOffset);</b>
<b class="fc"><i>878</i>&nbsp;                if (year &gt; iToYear) {</b>
<i>879</i>&nbsp;                    // Out of range, return original value.
<b class="fc"><i>880</i>&nbsp;                    next = instant;</b>
<i>881</i>&nbsp;                }
<i>882</i>&nbsp;            }
<i>883</i>&nbsp;
<b class="fc"><i>884</i>&nbsp;            return next;</b>
<i>885</i>&nbsp;        }
<i>886</i>&nbsp;        
<i>887</i>&nbsp;        @Override
<i>888</i>&nbsp;        public String toString() {
<b class="nc"><i>889</i>&nbsp;            return iFromYear + &quot; to &quot; + iToYear + &quot; using &quot; + iRecurrence;</b>
<i>890</i>&nbsp;        }
<i>891</i>&nbsp;    }
<i>892</i>&nbsp;
<i>893</i>&nbsp;    private static final class Transition {
<i>894</i>&nbsp;        private final long iMillis;
<i>895</i>&nbsp;        private final String iNameKey;
<i>896</i>&nbsp;        private final int iWallOffset;
<i>897</i>&nbsp;        private final int iStandardOffset;
<i>898</i>&nbsp;
<b class="fc"><i>899</i>&nbsp;        Transition(long millis, Transition tr) {</b>
<b class="fc"><i>900</i>&nbsp;            iMillis = millis;</b>
<b class="fc"><i>901</i>&nbsp;            iNameKey = tr.iNameKey;</b>
<b class="fc"><i>902</i>&nbsp;            iWallOffset = tr.iWallOffset;</b>
<b class="fc"><i>903</i>&nbsp;            iStandardOffset = tr.iStandardOffset;</b>
<b class="fc"><i>904</i>&nbsp;        }</b>
<i>905</i>&nbsp;
<b class="fc"><i>906</i>&nbsp;        Transition(long millis, Rule rule, int standardOffset) {</b>
<b class="fc"><i>907</i>&nbsp;            iMillis = millis;</b>
<b class="fc"><i>908</i>&nbsp;            iNameKey = rule.getNameKey();</b>
<b class="fc"><i>909</i>&nbsp;            iWallOffset = standardOffset + rule.getSaveMillis();</b>
<b class="fc"><i>910</i>&nbsp;            iStandardOffset = standardOffset;</b>
<b class="fc"><i>911</i>&nbsp;        }</b>
<i>912</i>&nbsp;
<i>913</i>&nbsp;        Transition(long millis, String nameKey,
<b class="fc"><i>914</i>&nbsp;                   int wallOffset, int standardOffset) {</b>
<b class="fc"><i>915</i>&nbsp;            iMillis = millis;</b>
<b class="fc"><i>916</i>&nbsp;            iNameKey = nameKey;</b>
<b class="fc"><i>917</i>&nbsp;            iWallOffset = wallOffset;</b>
<b class="fc"><i>918</i>&nbsp;            iStandardOffset = standardOffset;</b>
<b class="fc"><i>919</i>&nbsp;        }</b>
<i>920</i>&nbsp;
<i>921</i>&nbsp;        public long getMillis() {
<b class="fc"><i>922</i>&nbsp;            return iMillis;</b>
<i>923</i>&nbsp;        }
<i>924</i>&nbsp;
<i>925</i>&nbsp;        public String getNameKey() {
<b class="fc"><i>926</i>&nbsp;            return iNameKey;</b>
<i>927</i>&nbsp;        }
<i>928</i>&nbsp;
<i>929</i>&nbsp;        public int getWallOffset() {
<b class="fc"><i>930</i>&nbsp;            return iWallOffset;</b>
<i>931</i>&nbsp;        }
<i>932</i>&nbsp;
<i>933</i>&nbsp;        public int getStandardOffset() {
<b class="fc"><i>934</i>&nbsp;            return iStandardOffset;</b>
<i>935</i>&nbsp;        }
<i>936</i>&nbsp;
<i>937</i>&nbsp;        public int getSaveMillis() {
<b class="fc"><i>938</i>&nbsp;            return iWallOffset - iStandardOffset;</b>
<i>939</i>&nbsp;        }
<i>940</i>&nbsp;
<i>941</i>&nbsp;        public Transition withMillis(long millis) {
<b class="nc"><i>942</i>&nbsp;            return new Transition(millis, iNameKey, iWallOffset, iStandardOffset);</b>
<i>943</i>&nbsp;        }
<i>944</i>&nbsp;
<i>945</i>&nbsp;        /**
<i>946</i>&nbsp;         * There must be a change in the millis, wall offsets or name keys.
<i>947</i>&nbsp;         */
<i>948</i>&nbsp;        public boolean isTransitionFrom(Transition other) {
<b class="fc"><i>949</i>&nbsp;            if (other == null) {</b>
<b class="fc"><i>950</i>&nbsp;                return true;</b>
<i>951</i>&nbsp;            }
<b class="fc"><i>952</i>&nbsp;            return iMillis &gt; other.iMillis &amp;&amp;</b>
<i>953</i>&nbsp;                (iWallOffset != other.iWallOffset ||
<i>954</i>&nbsp;                 iStandardOffset != other.iStandardOffset ||
<b class="fc"><i>955</i>&nbsp;                 !(iNameKey.equals(other.iNameKey)));</b>
<i>956</i>&nbsp;        }
<i>957</i>&nbsp;        
<i>958</i>&nbsp;        @Override
<i>959</i>&nbsp;        public String toString() {
<b class="nc"><i>960</i>&nbsp;            return new DateTime(iMillis, DateTimeZone.UTC) + &quot; &quot; + iStandardOffset + &quot; &quot; + iWallOffset;</b>
<i>961</i>&nbsp;        }
<i>962</i>&nbsp;    }
<i>963</i>&nbsp;
<i>964</i>&nbsp;    private static final class RuleSet {
<i>965</i>&nbsp;        private static final int YEAR_LIMIT;
<i>966</i>&nbsp;
<i>967</i>&nbsp;        static {
<i>968</i>&nbsp;            // Don&#39;t pre-calculate more than 100 years into the future. Almost
<i>969</i>&nbsp;            // all zones will stop pre-calculating far sooner anyhow. Either a
<i>970</i>&nbsp;            // simple DST cycle is detected or the last rule is a fixed
<i>971</i>&nbsp;            // offset. If a zone has a fixed offset set more than 100 years
<i>972</i>&nbsp;            // into the future, then it won&#39;t be observed.
<b class="fc"><i>973</i>&nbsp;            long now = DateTimeUtils.currentTimeMillis();</b>
<b class="fc"><i>974</i>&nbsp;            YEAR_LIMIT = ISOChronology.getInstanceUTC().year().get(now) + 100;</b>
<b class="fc"><i>975</i>&nbsp;        }</b>
<i>976</i>&nbsp;
<i>977</i>&nbsp;        private int iStandardOffset;
<i>978</i>&nbsp;        private ArrayList&lt;Rule&gt; iRules;
<i>979</i>&nbsp;
<i>980</i>&nbsp;        // Optional.
<i>981</i>&nbsp;        private String iInitialNameKey;
<i>982</i>&nbsp;        private int iInitialSaveMillis;
<i>983</i>&nbsp;
<i>984</i>&nbsp;        // Upper limit is exclusive.
<i>985</i>&nbsp;        private int iUpperYear;
<i>986</i>&nbsp;        private OfYear iUpperOfYear;
<i>987</i>&nbsp;
<b class="fc"><i>988</i>&nbsp;        RuleSet() {</b>
<b class="fc"><i>989</i>&nbsp;            iRules = new ArrayList&lt;Rule&gt;(10);</b>
<b class="fc"><i>990</i>&nbsp;            iUpperYear = Integer.MAX_VALUE;</b>
<b class="fc"><i>991</i>&nbsp;        }</b>
<i>992</i>&nbsp;
<i>993</i>&nbsp;        /**
<i>994</i>&nbsp;         * Copy constructor.
<i>995</i>&nbsp;         */
<b class="fc"><i>996</i>&nbsp;        RuleSet(RuleSet rs) {</b>
<b class="fc"><i>997</i>&nbsp;            iStandardOffset = rs.iStandardOffset;</b>
<b class="fc"><i>998</i>&nbsp;            iRules = new ArrayList&lt;Rule&gt;(rs.iRules);</b>
<b class="fc"><i>999</i>&nbsp;            iInitialNameKey = rs.iInitialNameKey;</b>
<b class="fc"><i>1000</i>&nbsp;            iInitialSaveMillis = rs.iInitialSaveMillis;</b>
<b class="fc"><i>1001</i>&nbsp;            iUpperYear = rs.iUpperYear;</b>
<b class="fc"><i>1002</i>&nbsp;            iUpperOfYear = rs.iUpperOfYear;</b>
<b class="fc"><i>1003</i>&nbsp;        }</b>
<i>1004</i>&nbsp;
<i>1005</i>&nbsp;        @SuppressWarnings(&quot;unused&quot;)
<i>1006</i>&nbsp;        public int getStandardOffset() {
<b class="nc"><i>1007</i>&nbsp;            return iStandardOffset;</b>
<i>1008</i>&nbsp;        }
<i>1009</i>&nbsp;
<i>1010</i>&nbsp;        public void setStandardOffset(int standardOffset) {
<b class="fc"><i>1011</i>&nbsp;            iStandardOffset = standardOffset;</b>
<b class="fc"><i>1012</i>&nbsp;        }</b>
<i>1013</i>&nbsp;
<i>1014</i>&nbsp;        public void setFixedSavings(String nameKey, int saveMillis) {
<b class="fc"><i>1015</i>&nbsp;            iInitialNameKey = nameKey;</b>
<b class="fc"><i>1016</i>&nbsp;            iInitialSaveMillis = saveMillis;</b>
<b class="fc"><i>1017</i>&nbsp;        }</b>
<i>1018</i>&nbsp;
<i>1019</i>&nbsp;        public void addRule(Rule rule) {
<b class="fc"><i>1020</i>&nbsp;            if (!iRules.contains(rule)) {</b>
<b class="fc"><i>1021</i>&nbsp;                iRules.add(rule);</b>
<i>1022</i>&nbsp;            }
<b class="fc"><i>1023</i>&nbsp;        }</b>
<i>1024</i>&nbsp;
<i>1025</i>&nbsp;        public void setUpperLimit(int year, OfYear ofYear) {
<b class="fc"><i>1026</i>&nbsp;            iUpperYear = year;</b>
<b class="fc"><i>1027</i>&nbsp;            iUpperOfYear = ofYear;</b>
<b class="fc"><i>1028</i>&nbsp;        }</b>
<i>1029</i>&nbsp;
<i>1030</i>&nbsp;        /**
<i>1031</i>&nbsp;         * Returns a transition at firstMillis with the first name key and
<i>1032</i>&nbsp;         * offsets for this rule set. This method may return null.
<i>1033</i>&nbsp;         *
<i>1034</i>&nbsp;         * @param firstMillis millis of first transition
<i>1035</i>&nbsp;         */
<i>1036</i>&nbsp;        public Transition firstTransition(final long firstMillis) {
<b class="fc"><i>1037</i>&nbsp;            if (iInitialNameKey != null) {</b>
<i>1038</i>&nbsp;                // Initial zone info explicitly set, so don&#39;t search the rules.
<b class="fc"><i>1039</i>&nbsp;                return new Transition(firstMillis, iInitialNameKey,</b>
<i>1040</i>&nbsp;                                      iStandardOffset + iInitialSaveMillis, iStandardOffset);
<i>1041</i>&nbsp;            }
<i>1042</i>&nbsp;
<i>1043</i>&nbsp;            // Make a copy before we destroy the rules.
<b class="fc"><i>1044</i>&nbsp;            ArrayList&lt;Rule&gt; copy = new ArrayList&lt;Rule&gt;(iRules);</b>
<i>1045</i>&nbsp;
<i>1046</i>&nbsp;            // Iterate through all the transitions until firstMillis is
<i>1047</i>&nbsp;            // reached. Use the name key and savings for whatever rule reaches
<i>1048</i>&nbsp;            // the limit.
<i>1049</i>&nbsp;
<b class="fc"><i>1050</i>&nbsp;            long millis = Long.MIN_VALUE;</b>
<b class="fc"><i>1051</i>&nbsp;            int saveMillis = 0;</b>
<b class="fc"><i>1052</i>&nbsp;            Transition first = null;</b>
<i>1053</i>&nbsp;
<i>1054</i>&nbsp;            Transition next;
<b class="fc"><i>1055</i>&nbsp;            while ((next = nextTransition(millis, saveMillis)) != null) {</b>
<b class="fc"><i>1056</i>&nbsp;                millis = next.getMillis();</b>
<i>1057</i>&nbsp;
<b class="fc"><i>1058</i>&nbsp;                if (millis == firstMillis) {</b>
<b class="nc"><i>1059</i>&nbsp;                    first = new Transition(firstMillis, next);</b>
<b class="nc"><i>1060</i>&nbsp;                    break;</b>
<i>1061</i>&nbsp;                }
<i>1062</i>&nbsp;
<b class="fc"><i>1063</i>&nbsp;                if (millis &gt; firstMillis) {</b>
<b class="fc"><i>1064</i>&nbsp;                    if (first == null) {</b>
<i>1065</i>&nbsp;                        // Find first rule without savings. This way a more
<i>1066</i>&nbsp;                        // accurate nameKey is found even though no rule
<i>1067</i>&nbsp;                        // extends to the RuleSet&#39;s lower limit.
<b class="fc"><i>1068</i>&nbsp;                        for (Rule rule : copy) {</b>
<b class="fc"><i>1069</i>&nbsp;                            if (rule.getSaveMillis() == 0) {</b>
<b class="fc"><i>1070</i>&nbsp;                                first = new Transition(firstMillis, rule, iStandardOffset);</b>
<b class="fc"><i>1071</i>&nbsp;                                break;</b>
<i>1072</i>&nbsp;                            }
<b class="fc"><i>1073</i>&nbsp;                        }</b>
<i>1074</i>&nbsp;                    }
<b class="fc"><i>1075</i>&nbsp;                    if (first == null) {</b>
<i>1076</i>&nbsp;                        // Found no rule without savings. Create a transition
<i>1077</i>&nbsp;                        // with no savings anyhow, and use the best available
<i>1078</i>&nbsp;                        // name key.
<b class="nc"><i>1079</i>&nbsp;                        first = new Transition(firstMillis, next.getNameKey(),</b>
<i>1080</i>&nbsp;                                               iStandardOffset, iStandardOffset);
<i>1081</i>&nbsp;                    }
<i>1082</i>&nbsp;                    break;
<i>1083</i>&nbsp;                }
<i>1084</i>&nbsp;                
<i>1085</i>&nbsp;                // Set first to the best transition found so far, but next
<i>1086</i>&nbsp;                // iteration may find something closer to lower limit.
<b class="fc"><i>1087</i>&nbsp;                first = new Transition(firstMillis, next);</b>
<i>1088</i>&nbsp;
<b class="fc"><i>1089</i>&nbsp;                saveMillis = next.getSaveMillis();</b>
<i>1090</i>&nbsp;            }
<i>1091</i>&nbsp;
<b class="fc"><i>1092</i>&nbsp;            iRules = copy;</b>
<b class="fc"><i>1093</i>&nbsp;            return first;</b>
<i>1094</i>&nbsp;        }
<i>1095</i>&nbsp;
<i>1096</i>&nbsp;        /**
<i>1097</i>&nbsp;         * Returns null if RuleSet is exhausted or upper limit reached. Calling
<i>1098</i>&nbsp;         * this method will throw away rules as they each become
<i>1099</i>&nbsp;         * exhausted. Copy the RuleSet before using it to compute transitions.
<i>1100</i>&nbsp;         *
<i>1101</i>&nbsp;         * Returned transition may be a duplicate from previous
<i>1102</i>&nbsp;         * transition. Caller must call isTransitionFrom to filter out
<i>1103</i>&nbsp;         * duplicates.
<i>1104</i>&nbsp;         *
<i>1105</i>&nbsp;         * @param saveMillis savings before next transition
<i>1106</i>&nbsp;         */
<i>1107</i>&nbsp;        public Transition nextTransition(final long instant, final int saveMillis) {
<b class="fc"><i>1108</i>&nbsp;            Chronology chrono = ISOChronology.getInstanceUTC();</b>
<i>1109</i>&nbsp;
<i>1110</i>&nbsp;            // Find next matching rule.
<b class="fc"><i>1111</i>&nbsp;            Rule nextRule = null;</b>
<b class="fc"><i>1112</i>&nbsp;            long nextMillis = Long.MAX_VALUE;</b>
<i>1113</i>&nbsp;            
<b class="fc"><i>1114</i>&nbsp;            Iterator&lt;Rule&gt; it = iRules.iterator();</b>
<b class="fc"><i>1115</i>&nbsp;            while (it.hasNext()) {</b>
<b class="fc"><i>1116</i>&nbsp;                Rule rule = it.next();</b>
<b class="fc"><i>1117</i>&nbsp;                long next = rule.next(instant, iStandardOffset, saveMillis);</b>
<b class="fc"><i>1118</i>&nbsp;                if (next &lt;= instant) {</b>
<b class="fc"><i>1119</i>&nbsp;                    it.remove();</b>
<b class="fc"><i>1120</i>&nbsp;                    continue;</b>
<i>1121</i>&nbsp;                }
<i>1122</i>&nbsp;                // Even if next is same as previous next, choose the rule
<i>1123</i>&nbsp;                // in order for more recently added rules to override.
<b class="fc"><i>1124</i>&nbsp;                if (next &lt;= nextMillis) {</b>
<i>1125</i>&nbsp;                    // Found a better match.
<b class="fc"><i>1126</i>&nbsp;                    nextRule = rule;</b>
<b class="fc"><i>1127</i>&nbsp;                    nextMillis = next;</b>
<i>1128</i>&nbsp;                }
<b class="fc"><i>1129</i>&nbsp;            }</b>
<i>1130</i>&nbsp;            
<b class="fc"><i>1131</i>&nbsp;            if (nextRule == null) {</b>
<b class="fc"><i>1132</i>&nbsp;                return null;</b>
<i>1133</i>&nbsp;            }
<i>1134</i>&nbsp;            
<i>1135</i>&nbsp;            // Stop precalculating if year reaches some arbitrary limit.
<b class="fc"><i>1136</i>&nbsp;            if (chrono.year().get(nextMillis) &gt;= YEAR_LIMIT) {</b>
<b class="nc"><i>1137</i>&nbsp;                return null;</b>
<i>1138</i>&nbsp;            }
<i>1139</i>&nbsp;            
<i>1140</i>&nbsp;            // Check if upper limit reached or passed.
<b class="fc"><i>1141</i>&nbsp;            if (iUpperYear &lt; Integer.MAX_VALUE) {</b>
<b class="fc"><i>1142</i>&nbsp;                long upperMillis =</b>
<b class="fc"><i>1143</i>&nbsp;                    iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);</b>
<b class="fc"><i>1144</i>&nbsp;                if (nextMillis &gt;= upperMillis) {</b>
<i>1145</i>&nbsp;                    // At or after upper limit.
<b class="fc"><i>1146</i>&nbsp;                    return null;</b>
<i>1147</i>&nbsp;                }
<i>1148</i>&nbsp;            }
<i>1149</i>&nbsp;            
<b class="fc"><i>1150</i>&nbsp;            return new Transition(nextMillis, nextRule, iStandardOffset);</b>
<i>1151</i>&nbsp;        }
<i>1152</i>&nbsp;
<i>1153</i>&nbsp;        /**
<i>1154</i>&nbsp;         * @param saveMillis savings before upper limit
<i>1155</i>&nbsp;         */
<i>1156</i>&nbsp;        public long getUpperLimit(int saveMillis) {
<b class="fc"><i>1157</i>&nbsp;            if (iUpperYear == Integer.MAX_VALUE) {</b>
<b class="fc"><i>1158</i>&nbsp;                return Long.MAX_VALUE;</b>
<i>1159</i>&nbsp;            }
<b class="fc"><i>1160</i>&nbsp;            return iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);</b>
<i>1161</i>&nbsp;        }
<i>1162</i>&nbsp;
<i>1163</i>&nbsp;        /**
<i>1164</i>&nbsp;         * Returns null if none can be built.
<i>1165</i>&nbsp;         */
<i>1166</i>&nbsp;        public DSTZone buildTailZone(String id) {
<b class="fc"><i>1167</i>&nbsp;            if (iRules.size() == 2) {</b>
<b class="fc"><i>1168</i>&nbsp;                Rule startRule = iRules.get(0);</b>
<b class="fc"><i>1169</i>&nbsp;                Rule endRule = iRules.get(1);</b>
<b class="fc"><i>1170</i>&nbsp;                if (startRule.getToYear() == Integer.MAX_VALUE &amp;&amp;</b>
<b class="fc"><i>1171</i>&nbsp;                    endRule.getToYear() == Integer.MAX_VALUE) {</b>
<i>1172</i>&nbsp;
<i>1173</i>&nbsp;                    // With exactly two infinitely recurring rules left, a
<i>1174</i>&nbsp;                    // simple DSTZone can be formed.
<i>1175</i>&nbsp;
<i>1176</i>&nbsp;                    // The order of rules can come in any order, and it doesn&#39;t
<i>1177</i>&nbsp;                    // really matter which rule was chosen the &#39;start&#39; and
<i>1178</i>&nbsp;                    // which is chosen the &#39;end&#39;. DSTZone works properly either
<i>1179</i>&nbsp;                    // way.
<b class="fc"><i>1180</i>&nbsp;                    return new DSTZone(id, iStandardOffset,</b>
<i>1181</i>&nbsp;                                       startRule.iRecurrence, endRule.iRecurrence);
<i>1182</i>&nbsp;                }
<i>1183</i>&nbsp;            }
<b class="fc"><i>1184</i>&nbsp;            return null;</b>
<i>1185</i>&nbsp;        }
<i>1186</i>&nbsp;        
<i>1187</i>&nbsp;        @Override
<i>1188</i>&nbsp;        public String toString() {
<b class="nc"><i>1189</i>&nbsp;            return iInitialNameKey + &quot; initial: &quot; + iInitialSaveMillis + &quot; std: &quot; + iStandardOffset +</b>
<i>1190</i>&nbsp;                    &quot; upper: &quot; + iUpperYear + &quot; &quot; + iUpperOfYear + &quot; &quot; + iRules;
<i>1191</i>&nbsp;        }
<i>1192</i>&nbsp;    }
<i>1193</i>&nbsp;
<i>1194</i>&nbsp;    private static final class DSTZone extends DateTimeZone {
<i>1195</i>&nbsp;        private static final long serialVersionUID = 6941492635554961361L;
<i>1196</i>&nbsp;
<i>1197</i>&nbsp;        static DSTZone readFrom(DataInput in, String id) throws IOException {
<b class="fc"><i>1198</i>&nbsp;            return new DSTZone(id, (int)readMillis(in), </b>
<b class="fc"><i>1199</i>&nbsp;                               Recurrence.readFrom(in), Recurrence.readFrom(in));</b>
<i>1200</i>&nbsp;        }
<i>1201</i>&nbsp;
<i>1202</i>&nbsp;        final int iStandardOffset;
<i>1203</i>&nbsp;        final Recurrence iStartRecurrence;
<i>1204</i>&nbsp;        final Recurrence iEndRecurrence;
<i>1205</i>&nbsp;
<i>1206</i>&nbsp;        DSTZone(String id, int standardOffset,
<i>1207</i>&nbsp;                Recurrence startRecurrence, Recurrence endRecurrence) {
<b class="fc"><i>1208</i>&nbsp;            super(id);</b>
<b class="fc"><i>1209</i>&nbsp;            iStandardOffset = standardOffset;</b>
<b class="fc"><i>1210</i>&nbsp;            iStartRecurrence = startRecurrence;</b>
<b class="fc"><i>1211</i>&nbsp;            iEndRecurrence = endRecurrence;</b>
<b class="fc"><i>1212</i>&nbsp;        }</b>
<i>1213</i>&nbsp;
<i>1214</i>&nbsp;        public String getNameKey(long instant) {
<b class="fc"><i>1215</i>&nbsp;            return findMatchingRecurrence(instant).getNameKey();</b>
<i>1216</i>&nbsp;        }
<i>1217</i>&nbsp;
<i>1218</i>&nbsp;        public int getOffset(long instant) {
<b class="fc"><i>1219</i>&nbsp;            return iStandardOffset + findMatchingRecurrence(instant).getSaveMillis();</b>
<i>1220</i>&nbsp;        }
<i>1221</i>&nbsp;
<i>1222</i>&nbsp;        public int getStandardOffset(long instant) {
<b class="fc"><i>1223</i>&nbsp;            return iStandardOffset;</b>
<i>1224</i>&nbsp;        }
<i>1225</i>&nbsp;
<i>1226</i>&nbsp;        public boolean isFixed() {
<b class="nc"><i>1227</i>&nbsp;            return false;</b>
<i>1228</i>&nbsp;        }
<i>1229</i>&nbsp;
<i>1230</i>&nbsp;        public long nextTransition(long instant) {
<b class="fc"><i>1231</i>&nbsp;            int standardOffset = iStandardOffset;</b>
<b class="fc"><i>1232</i>&nbsp;            Recurrence startRecurrence = iStartRecurrence;</b>
<b class="fc"><i>1233</i>&nbsp;            Recurrence endRecurrence = iEndRecurrence;</b>
<i>1234</i>&nbsp;
<i>1235</i>&nbsp;            long start, end;
<i>1236</i>&nbsp;
<i>1237</i>&nbsp;            try {
<b class="fc"><i>1238</i>&nbsp;                start = startRecurrence.next</b>
<b class="fc"><i>1239</i>&nbsp;                    (instant, standardOffset, endRecurrence.getSaveMillis());</b>
<b class="fc"><i>1240</i>&nbsp;                if (instant &gt; 0 &amp;&amp; start &lt; 0) {</b>
<i>1241</i>&nbsp;                    // Overflowed.
<b class="nc"><i>1242</i>&nbsp;                    start = instant;</b>
<i>1243</i>&nbsp;                }
<b class="fc"><i>1244</i>&nbsp;            } catch (IllegalArgumentException e) {</b>
<i>1245</i>&nbsp;                // Overflowed.
<b class="fc"><i>1246</i>&nbsp;                start = instant;</b>
<b class="nc"><i>1247</i>&nbsp;            } catch (ArithmeticException e) {</b>
<i>1248</i>&nbsp;                // Overflowed.
<b class="nc"><i>1249</i>&nbsp;                start = instant;</b>
<b class="fc"><i>1250</i>&nbsp;            }</b>
<i>1251</i>&nbsp;
<i>1252</i>&nbsp;            try {
<b class="fc"><i>1253</i>&nbsp;                end = endRecurrence.next</b>
<b class="fc"><i>1254</i>&nbsp;                    (instant, standardOffset, startRecurrence.getSaveMillis());</b>
<b class="fc"><i>1255</i>&nbsp;                if (instant &gt; 0 &amp;&amp; end &lt; 0) {</b>
<i>1256</i>&nbsp;                    // Overflowed.
<b class="fc"><i>1257</i>&nbsp;                    end = instant;</b>
<i>1258</i>&nbsp;                }
<b class="fc"><i>1259</i>&nbsp;            } catch (IllegalArgumentException e) {</b>
<i>1260</i>&nbsp;                // Overflowed.
<b class="fc"><i>1261</i>&nbsp;                end = instant;</b>
<b class="nc"><i>1262</i>&nbsp;            } catch (ArithmeticException e) {</b>
<i>1263</i>&nbsp;                // Overflowed.
<b class="nc"><i>1264</i>&nbsp;                end = instant;</b>
<b class="fc"><i>1265</i>&nbsp;            }</b>
<i>1266</i>&nbsp;
<b class="fc"><i>1267</i>&nbsp;            return (start &gt; end) ? end : start;</b>
<i>1268</i>&nbsp;        }
<i>1269</i>&nbsp;
<i>1270</i>&nbsp;        public long previousTransition(long instant) {
<i>1271</i>&nbsp;            // Increment in order to handle the case where instant is exactly at
<i>1272</i>&nbsp;            // a transition.
<b class="fc"><i>1273</i>&nbsp;            instant++;</b>
<i>1274</i>&nbsp;
<b class="fc"><i>1275</i>&nbsp;            int standardOffset = iStandardOffset;</b>
<b class="fc"><i>1276</i>&nbsp;            Recurrence startRecurrence = iStartRecurrence;</b>
<b class="fc"><i>1277</i>&nbsp;            Recurrence endRecurrence = iEndRecurrence;</b>
<i>1278</i>&nbsp;
<i>1279</i>&nbsp;            long start, end;
<i>1280</i>&nbsp;
<i>1281</i>&nbsp;            try {
<b class="fc"><i>1282</i>&nbsp;                start = startRecurrence.previous</b>
<b class="fc"><i>1283</i>&nbsp;                    (instant, standardOffset, endRecurrence.getSaveMillis());</b>
<b class="fc"><i>1284</i>&nbsp;                if (instant &lt; 0 &amp;&amp; start &gt; 0) {</b>
<i>1285</i>&nbsp;                    // Overflowed.
<b class="nc"><i>1286</i>&nbsp;                    start = instant;</b>
<i>1287</i>&nbsp;                }
<b class="nc"><i>1288</i>&nbsp;            } catch (IllegalArgumentException e) {</b>
<i>1289</i>&nbsp;                // Overflowed.
<b class="nc"><i>1290</i>&nbsp;                start = instant;</b>
<b class="nc"><i>1291</i>&nbsp;            } catch (ArithmeticException e) {</b>
<i>1292</i>&nbsp;                // Overflowed.
<b class="nc"><i>1293</i>&nbsp;                start = instant;</b>
<b class="fc"><i>1294</i>&nbsp;            }</b>
<i>1295</i>&nbsp;
<i>1296</i>&nbsp;            try {
<b class="fc"><i>1297</i>&nbsp;                end = endRecurrence.previous</b>
<b class="fc"><i>1298</i>&nbsp;                    (instant, standardOffset, startRecurrence.getSaveMillis());</b>
<b class="fc"><i>1299</i>&nbsp;                if (instant &lt; 0 &amp;&amp; end &gt; 0) {</b>
<i>1300</i>&nbsp;                    // Overflowed.
<b class="nc"><i>1301</i>&nbsp;                    end = instant;</b>
<i>1302</i>&nbsp;                }
<b class="nc"><i>1303</i>&nbsp;            } catch (IllegalArgumentException e) {</b>
<i>1304</i>&nbsp;                // Overflowed.
<b class="nc"><i>1305</i>&nbsp;                end = instant;</b>
<b class="nc"><i>1306</i>&nbsp;            } catch (ArithmeticException e) {</b>
<i>1307</i>&nbsp;                // Overflowed.
<b class="nc"><i>1308</i>&nbsp;                end = instant;</b>
<b class="fc"><i>1309</i>&nbsp;            }</b>
<i>1310</i>&nbsp;
<b class="fc"><i>1311</i>&nbsp;            return ((start &gt; end) ? start : end) - 1;</b>
<i>1312</i>&nbsp;        }
<i>1313</i>&nbsp;
<i>1314</i>&nbsp;        public boolean equals(Object obj) {
<b class="fc"><i>1315</i>&nbsp;            if (this == obj) {</b>
<b class="nc"><i>1316</i>&nbsp;                return true;</b>
<i>1317</i>&nbsp;            }
<b class="fc"><i>1318</i>&nbsp;            if (obj instanceof DSTZone) {</b>
<b class="fc"><i>1319</i>&nbsp;                DSTZone other = (DSTZone)obj;</b>
<b class="fc"><i>1320</i>&nbsp;                return</b>
<b class="fc"><i>1321</i>&nbsp;                    getID().equals(other.getID()) &amp;&amp;</b>
<i>1322</i>&nbsp;                    iStandardOffset == other.iStandardOffset &amp;&amp;
<b class="fc"><i>1323</i>&nbsp;                    iStartRecurrence.equals(other.iStartRecurrence) &amp;&amp;</b>
<b class="fc"><i>1324</i>&nbsp;                    iEndRecurrence.equals(other.iEndRecurrence);</b>
<i>1325</i>&nbsp;            }
<b class="nc"><i>1326</i>&nbsp;            return false;</b>
<i>1327</i>&nbsp;        }
<i>1328</i>&nbsp;
<i>1329</i>&nbsp;        public void writeTo(DataOutput out) throws IOException {
<b class="fc"><i>1330</i>&nbsp;            writeMillis(out, iStandardOffset);</b>
<b class="fc"><i>1331</i>&nbsp;            iStartRecurrence.writeTo(out);</b>
<b class="fc"><i>1332</i>&nbsp;            iEndRecurrence.writeTo(out);</b>
<b class="fc"><i>1333</i>&nbsp;        }</b>
<i>1334</i>&nbsp;
<i>1335</i>&nbsp;        private Recurrence findMatchingRecurrence(long instant) {
<b class="fc"><i>1336</i>&nbsp;            int standardOffset = iStandardOffset;</b>
<b class="fc"><i>1337</i>&nbsp;            Recurrence startRecurrence = iStartRecurrence;</b>
<b class="fc"><i>1338</i>&nbsp;            Recurrence endRecurrence = iEndRecurrence;</b>
<i>1339</i>&nbsp;
<i>1340</i>&nbsp;            long start, end;
<i>1341</i>&nbsp;
<i>1342</i>&nbsp;            try {
<b class="fc"><i>1343</i>&nbsp;                start = startRecurrence.next</b>
<b class="fc"><i>1344</i>&nbsp;                    (instant, standardOffset, endRecurrence.getSaveMillis());</b>
<b class="fc"><i>1345</i>&nbsp;            } catch (IllegalArgumentException e) {</b>
<i>1346</i>&nbsp;                // Overflowed.
<b class="fc"><i>1347</i>&nbsp;                start = instant;</b>
<b class="nc"><i>1348</i>&nbsp;            } catch (ArithmeticException e) {</b>
<i>1349</i>&nbsp;                // Overflowed.
<b class="nc"><i>1350</i>&nbsp;                start = instant;</b>
<b class="fc"><i>1351</i>&nbsp;            }</b>
<i>1352</i>&nbsp;
<i>1353</i>&nbsp;            try {
<b class="fc"><i>1354</i>&nbsp;                end = endRecurrence.next</b>
<b class="fc"><i>1355</i>&nbsp;                    (instant, standardOffset, startRecurrence.getSaveMillis());</b>
<b class="fc"><i>1356</i>&nbsp;            } catch (IllegalArgumentException e) {</b>
<i>1357</i>&nbsp;                // Overflowed.
<b class="fc"><i>1358</i>&nbsp;                end = instant;</b>
<b class="nc"><i>1359</i>&nbsp;            } catch (ArithmeticException e) {</b>
<i>1360</i>&nbsp;                // Overflowed.
<b class="nc"><i>1361</i>&nbsp;                end = instant;</b>
<b class="fc"><i>1362</i>&nbsp;            }</b>
<i>1363</i>&nbsp;
<b class="fc"><i>1364</i>&nbsp;            return (start &gt; end) ? startRecurrence : endRecurrence;</b>
<i>1365</i>&nbsp;        }
<i>1366</i>&nbsp;    }
<i>1367</i>&nbsp;
<i>1368</i>&nbsp;    private static final class PrecalculatedZone extends DateTimeZone {
<i>1369</i>&nbsp;        private static final long serialVersionUID = 7811976468055766265L;
<i>1370</i>&nbsp;
<i>1371</i>&nbsp;        static PrecalculatedZone readFrom(DataInput in, String id) throws IOException {
<i>1372</i>&nbsp;            // Read string pool.
<b class="fc"><i>1373</i>&nbsp;            int poolSize = in.readUnsignedShort();</b>
<b class="fc"><i>1374</i>&nbsp;            String[] pool = new String[poolSize];</b>
<b class="fc"><i>1375</i>&nbsp;            for (int i=0; i&lt;poolSize; i++) {</b>
<b class="fc"><i>1376</i>&nbsp;                pool[i] = in.readUTF();</b>
<i>1377</i>&nbsp;            }
<i>1378</i>&nbsp;
<b class="fc"><i>1379</i>&nbsp;            int size = in.readInt();</b>
<b class="fc"><i>1380</i>&nbsp;            long[] transitions = new long[size];</b>
<b class="fc"><i>1381</i>&nbsp;            int[] wallOffsets = new int[size];</b>
<b class="fc"><i>1382</i>&nbsp;            int[] standardOffsets = new int[size];</b>
<b class="fc"><i>1383</i>&nbsp;            String[] nameKeys = new String[size];</b>
<i>1384</i>&nbsp;            
<b class="fc"><i>1385</i>&nbsp;            for (int i=0; i&lt;size; i++) {</b>
<b class="fc"><i>1386</i>&nbsp;                transitions[i] = readMillis(in);</b>
<b class="fc"><i>1387</i>&nbsp;                wallOffsets[i] = (int)readMillis(in);</b>
<b class="fc"><i>1388</i>&nbsp;                standardOffsets[i] = (int)readMillis(in);</b>
<i>1389</i>&nbsp;                try {
<i>1390</i>&nbsp;                    int index;
<b class="fc"><i>1391</i>&nbsp;                    if (poolSize &lt; 256) {</b>
<b class="fc"><i>1392</i>&nbsp;                        index = in.readUnsignedByte();</b>
<i>1393</i>&nbsp;                    } else {
<b class="nc"><i>1394</i>&nbsp;                        index = in.readUnsignedShort();</b>
<i>1395</i>&nbsp;                    }
<b class="fc"><i>1396</i>&nbsp;                    nameKeys[i] = pool[index];</b>
<b class="nc"><i>1397</i>&nbsp;                } catch (ArrayIndexOutOfBoundsException e) {</b>
<b class="nc"><i>1398</i>&nbsp;                    throw new IOException(&quot;Invalid encoding&quot;);</b>
<b class="fc"><i>1399</i>&nbsp;                }</b>
<i>1400</i>&nbsp;            }
<i>1401</i>&nbsp;
<b class="fc"><i>1402</i>&nbsp;            DSTZone tailZone = null;</b>
<b class="fc"><i>1403</i>&nbsp;            if (in.readBoolean()) {</b>
<b class="fc"><i>1404</i>&nbsp;                tailZone = DSTZone.readFrom(in, id);</b>
<i>1405</i>&nbsp;            }
<i>1406</i>&nbsp;
<b class="fc"><i>1407</i>&nbsp;            return new PrecalculatedZone</b>
<i>1408</i>&nbsp;                (id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone);
<i>1409</i>&nbsp;        }
<i>1410</i>&nbsp;
<i>1411</i>&nbsp;        /**
<i>1412</i>&nbsp;         * Factory to create instance from builder.
<i>1413</i>&nbsp;         * 
<i>1414</i>&nbsp;         * @param id  the zone id
<i>1415</i>&nbsp;         * @param outputID  true if the zone id should be output
<i>1416</i>&nbsp;         * @param transitions  the list of Transition objects
<i>1417</i>&nbsp;         * @param tailZone  optional zone for getting info beyond precalculated tables
<i>1418</i>&nbsp;         */
<i>1419</i>&nbsp;        static PrecalculatedZone create(String id, boolean outputID, ArrayList&lt;Transition&gt; transitions,
<i>1420</i>&nbsp;                                        DSTZone tailZone) {
<b class="fc"><i>1421</i>&nbsp;            int size = transitions.size();</b>
<b class="fc"><i>1422</i>&nbsp;            if (size == 0) {</b>
<b class="nc"><i>1423</i>&nbsp;                throw new IllegalArgumentException();</b>
<i>1424</i>&nbsp;            }
<i>1425</i>&nbsp;
<b class="fc"><i>1426</i>&nbsp;            long[] trans = new long[size];</b>
<b class="fc"><i>1427</i>&nbsp;            int[] wallOffsets = new int[size];</b>
<b class="fc"><i>1428</i>&nbsp;            int[] standardOffsets = new int[size];</b>
<b class="fc"><i>1429</i>&nbsp;            String[] nameKeys = new String[size];</b>
<i>1430</i>&nbsp;
<b class="fc"><i>1431</i>&nbsp;            Transition last = null;</b>
<b class="fc"><i>1432</i>&nbsp;            for (int i=0; i&lt;size; i++) {</b>
<b class="fc"><i>1433</i>&nbsp;                Transition tr = transitions.get(i);</b>
<i>1434</i>&nbsp;
<b class="fc"><i>1435</i>&nbsp;                if (!tr.isTransitionFrom(last)) {</b>
<b class="nc"><i>1436</i>&nbsp;                    throw new IllegalArgumentException(id);</b>
<i>1437</i>&nbsp;                }
<i>1438</i>&nbsp;
<b class="fc"><i>1439</i>&nbsp;                trans[i] = tr.getMillis();</b>
<b class="fc"><i>1440</i>&nbsp;                wallOffsets[i] = tr.getWallOffset();</b>
<b class="fc"><i>1441</i>&nbsp;                standardOffsets[i] = tr.getStandardOffset();</b>
<b class="fc"><i>1442</i>&nbsp;                nameKeys[i] = tr.getNameKey();</b>
<i>1443</i>&nbsp;
<b class="fc"><i>1444</i>&nbsp;                last = tr;</b>
<i>1445</i>&nbsp;            }
<i>1446</i>&nbsp;
<i>1447</i>&nbsp;            // Some timezones (Australia) have the same name key for
<i>1448</i>&nbsp;            // summer and winter which messes everything up. Fix it here.
<b class="fc"><i>1449</i>&nbsp;            String[] zoneNameData = new String[5];</b>
<b class="fc"><i>1450</i>&nbsp;            String[][] zoneStrings = new DateFormatSymbols(Locale.ENGLISH).getZoneStrings();</b>
<b class="fc"><i>1451</i>&nbsp;            for (int j = 0; j &lt; zoneStrings.length; j++) {</b>
<b class="fc"><i>1452</i>&nbsp;                String[] set = zoneStrings[j];</b>
<b class="fc"><i>1453</i>&nbsp;                if (set != null &amp;&amp; set.length == 5 &amp;&amp; id.equals(set[0])) {</b>
<b class="nc"><i>1454</i>&nbsp;                    zoneNameData = set;</b>
<i>1455</i>&nbsp;                }
<i>1456</i>&nbsp;            }
<i>1457</i>&nbsp;
<b class="fc"><i>1458</i>&nbsp;            Chronology chrono = ISOChronology.getInstanceUTC();</b>
<i>1459</i>&nbsp;
<b class="fc"><i>1460</i>&nbsp;            for (int i = 0; i &lt; nameKeys.length - 1; i++) {</b>
<b class="fc"><i>1461</i>&nbsp;                String curNameKey = nameKeys[i];</b>
<b class="fc"><i>1462</i>&nbsp;                String nextNameKey = nameKeys[i + 1];</b>
<b class="fc"><i>1463</i>&nbsp;                long curOffset = wallOffsets[i];</b>
<b class="fc"><i>1464</i>&nbsp;                long nextOffset = wallOffsets[i + 1];</b>
<b class="fc"><i>1465</i>&nbsp;                long curStdOffset = standardOffsets[i];</b>
<b class="fc"><i>1466</i>&nbsp;                long nextStdOffset = standardOffsets[i + 1];</b>
<b class="fc"><i>1467</i>&nbsp;                Period p = new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay(), chrono);</b>
<b class="fc"><i>1468</i>&nbsp;                if (curOffset != nextOffset &amp;&amp;</b>
<i>1469</i>&nbsp;                        curStdOffset == nextStdOffset &amp;&amp;
<b class="fc"><i>1470</i>&nbsp;                        curNameKey.equals(nextNameKey) &amp;&amp;</b>
<b class="fc"><i>1471</i>&nbsp;                        p.getYears() == 0 &amp;&amp; p.getMonths() &gt; 4 &amp;&amp; p.getMonths() &lt; 8 &amp;&amp;</b>
<b class="fc"><i>1472</i>&nbsp;                        curNameKey.equals(zoneNameData[2]) &amp;&amp;</b>
<b class="nc"><i>1473</i>&nbsp;                        curNameKey.equals(zoneNameData[4])) {</b>
<i>1474</i>&nbsp;                    
<b class="nc"><i>1475</i>&nbsp;                    if (ZoneInfoLogger.verbose()) {</b>
<b class="nc"><i>1476</i>&nbsp;                        System.out.println(&quot;Fixing duplicate name key - &quot; + nextNameKey);</b>
<b class="nc"><i>1477</i>&nbsp;                        System.out.println(&quot;     - &quot; + new DateTime(trans[i], chrono) +</b>
<i>1478</i>&nbsp;                                           &quot; - &quot; + new DateTime(trans[i + 1], chrono));
<i>1479</i>&nbsp;                    }
<b class="nc"><i>1480</i>&nbsp;                    if (curOffset &gt; nextOffset) {</b>
<b class="nc"><i>1481</i>&nbsp;                        nameKeys[i] = (curNameKey + &quot;-Summer&quot;).intern();</b>
<b class="nc"><i>1482</i>&nbsp;                    } else if (curOffset &lt; nextOffset) {</b>
<b class="nc"><i>1483</i>&nbsp;                        nameKeys[i + 1] = (nextNameKey + &quot;-Summer&quot;).intern();</b>
<b class="nc"><i>1484</i>&nbsp;                        i++;</b>
<i>1485</i>&nbsp;                    }
<i>1486</i>&nbsp;                }
<i>1487</i>&nbsp;            }
<i>1488</i>&nbsp;
<b class="fc"><i>1489</i>&nbsp;            if (tailZone != null) {</b>
<b class="fc"><i>1490</i>&nbsp;                if (tailZone.iStartRecurrence.getNameKey()</b>
<b class="fc"><i>1491</i>&nbsp;                    .equals(tailZone.iEndRecurrence.getNameKey())) {</b>
<b class="fc"><i>1492</i>&nbsp;                    if (ZoneInfoLogger.verbose()) {</b>
<b class="nc"><i>1493</i>&nbsp;                        System.out.println(&quot;Fixing duplicate recurrent name key - &quot; +</b>
<b class="nc"><i>1494</i>&nbsp;                                           tailZone.iStartRecurrence.getNameKey());</b>
<i>1495</i>&nbsp;                    }
<b class="fc"><i>1496</i>&nbsp;                    if (tailZone.iStartRecurrence.getSaveMillis() &gt; 0) {</b>
<b class="fc"><i>1497</i>&nbsp;                        tailZone = new DSTZone(</b>
<b class="fc"><i>1498</i>&nbsp;                            tailZone.getID(),</b>
<i>1499</i>&nbsp;                            tailZone.iStandardOffset,
<b class="fc"><i>1500</i>&nbsp;                            tailZone.iStartRecurrence.renameAppend(&quot;-Summer&quot;),</b>
<i>1501</i>&nbsp;                            tailZone.iEndRecurrence);
<i>1502</i>&nbsp;                    } else {
<b class="nc"><i>1503</i>&nbsp;                        tailZone = new DSTZone(</b>
<b class="nc"><i>1504</i>&nbsp;                            tailZone.getID(),</b>
<i>1505</i>&nbsp;                            tailZone.iStandardOffset,
<i>1506</i>&nbsp;                            tailZone.iStartRecurrence,
<b class="nc"><i>1507</i>&nbsp;                            tailZone.iEndRecurrence.renameAppend(&quot;-Summer&quot;));</b>
<i>1508</i>&nbsp;                    }
<i>1509</i>&nbsp;                }
<i>1510</i>&nbsp;            }
<i>1511</i>&nbsp;            
<b class="fc"><i>1512</i>&nbsp;            return new PrecalculatedZone</b>
<i>1513</i>&nbsp;                ((outputID ? id : &quot;&quot;), trans, wallOffsets, standardOffsets, nameKeys, tailZone);
<i>1514</i>&nbsp;        }
<i>1515</i>&nbsp;
<i>1516</i>&nbsp;        // All array fields have the same length.
<i>1517</i>&nbsp;
<i>1518</i>&nbsp;        private final long[] iTransitions;
<i>1519</i>&nbsp;
<i>1520</i>&nbsp;        private final int[] iWallOffsets;
<i>1521</i>&nbsp;        private final int[] iStandardOffsets;
<i>1522</i>&nbsp;        private final String[] iNameKeys;
<i>1523</i>&nbsp;
<i>1524</i>&nbsp;        private final DSTZone iTailZone;
<i>1525</i>&nbsp;
<i>1526</i>&nbsp;        /**
<i>1527</i>&nbsp;         * Constructor used ONLY for valid input, loaded via static methods.
<i>1528</i>&nbsp;         */
<i>1529</i>&nbsp;        private PrecalculatedZone(String id, long[] transitions, int[] wallOffsets,
<i>1530</i>&nbsp;                          int[] standardOffsets, String[] nameKeys, DSTZone tailZone)
<i>1531</i>&nbsp;        {
<b class="fc"><i>1532</i>&nbsp;            super(id);</b>
<b class="fc"><i>1533</i>&nbsp;            iTransitions = transitions;</b>
<b class="fc"><i>1534</i>&nbsp;            iWallOffsets = wallOffsets;</b>
<b class="fc"><i>1535</i>&nbsp;            iStandardOffsets = standardOffsets;</b>
<b class="fc"><i>1536</i>&nbsp;            iNameKeys = nameKeys;</b>
<b class="fc"><i>1537</i>&nbsp;            iTailZone = tailZone;</b>
<b class="fc"><i>1538</i>&nbsp;        }</b>
<i>1539</i>&nbsp;
<i>1540</i>&nbsp;        public String getNameKey(long instant) {
<b class="fc"><i>1541</i>&nbsp;            long[] transitions = iTransitions;</b>
<b class="fc"><i>1542</i>&nbsp;            int i = Arrays.binarySearch(transitions, instant);</b>
<b class="fc"><i>1543</i>&nbsp;            if (i &gt;= 0) {</b>
<b class="fc"><i>1544</i>&nbsp;                return iNameKeys[i];</b>
<i>1545</i>&nbsp;            }
<b class="fc"><i>1546</i>&nbsp;            i = ~i;</b>
<b class="fc"><i>1547</i>&nbsp;            if (i &lt; transitions.length) {</b>
<b class="fc"><i>1548</i>&nbsp;                if (i &gt; 0) {</b>
<b class="fc"><i>1549</i>&nbsp;                    return iNameKeys[i - 1];</b>
<i>1550</i>&nbsp;                }
<b class="nc"><i>1551</i>&nbsp;                return &quot;UTC&quot;;</b>
<i>1552</i>&nbsp;            }
<b class="fc"><i>1553</i>&nbsp;            if (iTailZone == null) {</b>
<b class="fc"><i>1554</i>&nbsp;                return iNameKeys[i - 1];</b>
<i>1555</i>&nbsp;            }
<b class="fc"><i>1556</i>&nbsp;            return iTailZone.getNameKey(instant);</b>
<i>1557</i>&nbsp;        }
<i>1558</i>&nbsp;
<i>1559</i>&nbsp;        public int getOffset(long instant) {
<b class="fc"><i>1560</i>&nbsp;            long[] transitions = iTransitions;</b>
<b class="fc"><i>1561</i>&nbsp;            int i = Arrays.binarySearch(transitions, instant);</b>
<b class="fc"><i>1562</i>&nbsp;            if (i &gt;= 0) {</b>
<b class="fc"><i>1563</i>&nbsp;                return iWallOffsets[i];</b>
<i>1564</i>&nbsp;            }
<b class="fc"><i>1565</i>&nbsp;            i = ~i;</b>
<b class="fc"><i>1566</i>&nbsp;            if (i &lt; transitions.length) {</b>
<b class="fc"><i>1567</i>&nbsp;                if (i &gt; 0) {</b>
<b class="fc"><i>1568</i>&nbsp;                    return iWallOffsets[i - 1];</b>
<i>1569</i>&nbsp;                }
<b class="nc"><i>1570</i>&nbsp;                return 0;</b>
<i>1571</i>&nbsp;            }
<b class="fc"><i>1572</i>&nbsp;            if (iTailZone == null) {</b>
<b class="fc"><i>1573</i>&nbsp;                return iWallOffsets[i - 1];</b>
<i>1574</i>&nbsp;            }
<b class="fc"><i>1575</i>&nbsp;            return iTailZone.getOffset(instant);</b>
<i>1576</i>&nbsp;        }
<i>1577</i>&nbsp;
<i>1578</i>&nbsp;        public int getStandardOffset(long instant) {
<b class="fc"><i>1579</i>&nbsp;            long[] transitions = iTransitions;</b>
<b class="fc"><i>1580</i>&nbsp;            int i = Arrays.binarySearch(transitions, instant);</b>
<b class="fc"><i>1581</i>&nbsp;            if (i &gt;= 0) {</b>
<b class="fc"><i>1582</i>&nbsp;                return iStandardOffsets[i];</b>
<i>1583</i>&nbsp;            }
<b class="fc"><i>1584</i>&nbsp;            i = ~i;</b>
<b class="fc"><i>1585</i>&nbsp;            if (i &lt; transitions.length) {</b>
<b class="fc"><i>1586</i>&nbsp;                if (i &gt; 0) {</b>
<b class="fc"><i>1587</i>&nbsp;                    return iStandardOffsets[i - 1];</b>
<i>1588</i>&nbsp;                }
<b class="nc"><i>1589</i>&nbsp;                return 0;</b>
<i>1590</i>&nbsp;            }
<b class="fc"><i>1591</i>&nbsp;            if (iTailZone == null) {</b>
<b class="fc"><i>1592</i>&nbsp;                return iStandardOffsets[i - 1];</b>
<i>1593</i>&nbsp;            }
<b class="fc"><i>1594</i>&nbsp;            return iTailZone.getStandardOffset(instant);</b>
<i>1595</i>&nbsp;        }
<i>1596</i>&nbsp;
<i>1597</i>&nbsp;        public boolean isFixed() {
<b class="fc"><i>1598</i>&nbsp;            return false;</b>
<i>1599</i>&nbsp;        }
<i>1600</i>&nbsp;
<i>1601</i>&nbsp;        public long nextTransition(long instant) {
<b class="fc"><i>1602</i>&nbsp;            long[] transitions = iTransitions;</b>
<b class="fc"><i>1603</i>&nbsp;            int i = Arrays.binarySearch(transitions, instant);</b>
<b class="fc"><i>1604</i>&nbsp;            i = (i &gt;= 0) ? (i + 1) : ~i;</b>
<b class="fc"><i>1605</i>&nbsp;            if (i &lt; transitions.length) {</b>
<b class="fc"><i>1606</i>&nbsp;                return transitions[i];</b>
<i>1607</i>&nbsp;            }
<b class="fc"><i>1608</i>&nbsp;            if (iTailZone == null) {</b>
<b class="fc"><i>1609</i>&nbsp;                return instant;</b>
<i>1610</i>&nbsp;            }
<b class="fc"><i>1611</i>&nbsp;            long end = transitions[transitions.length - 1];</b>
<b class="fc"><i>1612</i>&nbsp;            if (instant &lt; end) {</b>
<b class="nc"><i>1613</i>&nbsp;                instant = end;</b>
<i>1614</i>&nbsp;            }
<b class="fc"><i>1615</i>&nbsp;            return iTailZone.nextTransition(instant);</b>
<i>1616</i>&nbsp;        }
<i>1617</i>&nbsp;
<i>1618</i>&nbsp;        public long previousTransition(long instant) {
<b class="fc"><i>1619</i>&nbsp;            long[] transitions = iTransitions;</b>
<b class="fc"><i>1620</i>&nbsp;            int i = Arrays.binarySearch(transitions, instant);</b>
<b class="fc"><i>1621</i>&nbsp;            if (i &gt;= 0) {</b>
<b class="fc"><i>1622</i>&nbsp;                if (instant &gt; Long.MIN_VALUE) {</b>
<b class="fc"><i>1623</i>&nbsp;                    return instant - 1;</b>
<i>1624</i>&nbsp;                }
<b class="nc"><i>1625</i>&nbsp;                return instant;</b>
<i>1626</i>&nbsp;            }
<b class="fc"><i>1627</i>&nbsp;            i = ~i;</b>
<b class="fc"><i>1628</i>&nbsp;            if (i &lt; transitions.length) {</b>
<b class="fc"><i>1629</i>&nbsp;                if (i &gt; 0) {</b>
<b class="fc"><i>1630</i>&nbsp;                    long prev = transitions[i - 1];</b>
<b class="fc"><i>1631</i>&nbsp;                    if (prev &gt; Long.MIN_VALUE) {</b>
<b class="fc"><i>1632</i>&nbsp;                        return prev - 1;</b>
<i>1633</i>&nbsp;                    }
<i>1634</i>&nbsp;                }
<b class="nc"><i>1635</i>&nbsp;                return instant;</b>
<i>1636</i>&nbsp;            }
<b class="fc"><i>1637</i>&nbsp;            if (iTailZone != null) {</b>
<b class="fc"><i>1638</i>&nbsp;                long prev = iTailZone.previousTransition(instant);</b>
<b class="fc"><i>1639</i>&nbsp;                if (prev &lt; instant) {</b>
<b class="fc"><i>1640</i>&nbsp;                    return prev;</b>
<i>1641</i>&nbsp;                }
<i>1642</i>&nbsp;            }
<b class="fc"><i>1643</i>&nbsp;            long prev = transitions[i - 1];</b>
<b class="fc"><i>1644</i>&nbsp;            if (prev &gt; Long.MIN_VALUE) {</b>
<b class="fc"><i>1645</i>&nbsp;                return prev - 1;</b>
<i>1646</i>&nbsp;            }
<b class="nc"><i>1647</i>&nbsp;            return instant;</b>
<i>1648</i>&nbsp;        }
<i>1649</i>&nbsp;
<i>1650</i>&nbsp;        public boolean equals(Object obj) {
<b class="fc"><i>1651</i>&nbsp;            if (this == obj) {</b>
<b class="fc"><i>1652</i>&nbsp;                return true;</b>
<i>1653</i>&nbsp;            }
<b class="fc"><i>1654</i>&nbsp;            if (obj instanceof PrecalculatedZone) {</b>
<b class="fc"><i>1655</i>&nbsp;                PrecalculatedZone other = (PrecalculatedZone)obj;</b>
<b class="fc"><i>1656</i>&nbsp;                return</b>
<b class="fc"><i>1657</i>&nbsp;                    getID().equals(other.getID()) &amp;&amp;</b>
<b class="fc"><i>1658</i>&nbsp;                    Arrays.equals(iTransitions, other.iTransitions) &amp;&amp;</b>
<b class="fc"><i>1659</i>&nbsp;                    Arrays.equals(iNameKeys, other.iNameKeys) &amp;&amp;</b>
<b class="fc"><i>1660</i>&nbsp;                    Arrays.equals(iWallOffsets, other.iWallOffsets) &amp;&amp;</b>
<b class="fc"><i>1661</i>&nbsp;                    Arrays.equals(iStandardOffsets, other.iStandardOffsets) &amp;&amp;</b>
<i>1662</i>&nbsp;                    ((iTailZone == null)
<i>1663</i>&nbsp;                     ? (null == other.iTailZone)
<b class="fc"><i>1664</i>&nbsp;                     : (iTailZone.equals(other.iTailZone)));</b>
<i>1665</i>&nbsp;            }
<b class="nc"><i>1666</i>&nbsp;            return false;</b>
<i>1667</i>&nbsp;        }
<i>1668</i>&nbsp;
<i>1669</i>&nbsp;        public void writeTo(DataOutput out) throws IOException {
<b class="fc"><i>1670</i>&nbsp;            int size = iTransitions.length;</b>
<i>1671</i>&nbsp;
<i>1672</i>&nbsp;            // Create unique string pool.
<b class="fc"><i>1673</i>&nbsp;            Set&lt;String&gt; poolSet = new HashSet&lt;String&gt;();</b>
<b class="fc"><i>1674</i>&nbsp;            for (int i=0; i&lt;size; i++) {</b>
<b class="fc"><i>1675</i>&nbsp;                poolSet.add(iNameKeys[i]);</b>
<i>1676</i>&nbsp;            }
<i>1677</i>&nbsp;
<b class="fc"><i>1678</i>&nbsp;            int poolSize = poolSet.size();</b>
<b class="fc"><i>1679</i>&nbsp;            if (poolSize &gt; 65535) {</b>
<b class="nc"><i>1680</i>&nbsp;                throw new UnsupportedOperationException(&quot;String pool is too large&quot;);</b>
<i>1681</i>&nbsp;            }
<b class="fc"><i>1682</i>&nbsp;            String[] pool = new String[poolSize];</b>
<b class="fc"><i>1683</i>&nbsp;            Iterator&lt;String&gt; it = poolSet.iterator();</b>
<b class="fc"><i>1684</i>&nbsp;            for (int i=0; it.hasNext(); i++) {</b>
<b class="fc"><i>1685</i>&nbsp;                pool[i] = it.next();</b>
<i>1686</i>&nbsp;            }
<i>1687</i>&nbsp;
<i>1688</i>&nbsp;            // Write out the pool.
<b class="fc"><i>1689</i>&nbsp;            out.writeShort(poolSize);</b>
<b class="fc"><i>1690</i>&nbsp;            for (int i=0; i&lt;poolSize; i++) {</b>
<b class="fc"><i>1691</i>&nbsp;                out.writeUTF(pool[i]);</b>
<i>1692</i>&nbsp;            }
<i>1693</i>&nbsp;
<b class="fc"><i>1694</i>&nbsp;            out.writeInt(size);</b>
<i>1695</i>&nbsp;
<b class="fc"><i>1696</i>&nbsp;            for (int i=0; i&lt;size; i++) {</b>
<b class="fc"><i>1697</i>&nbsp;                writeMillis(out, iTransitions[i]);</b>
<b class="fc"><i>1698</i>&nbsp;                writeMillis(out, iWallOffsets[i]);</b>
<b class="fc"><i>1699</i>&nbsp;                writeMillis(out, iStandardOffsets[i]);</b>
<i>1700</i>&nbsp;                
<i>1701</i>&nbsp;                // Find pool index and write it out.
<b class="fc"><i>1702</i>&nbsp;                String nameKey = iNameKeys[i];</b>
<b class="fc"><i>1703</i>&nbsp;                for (int j=0; j&lt;poolSize; j++) {</b>
<b class="fc"><i>1704</i>&nbsp;                    if (pool[j].equals(nameKey)) {</b>
<b class="fc"><i>1705</i>&nbsp;                        if (poolSize &lt; 256) {</b>
<b class="fc"><i>1706</i>&nbsp;                            out.writeByte(j);</b>
<i>1707</i>&nbsp;                        } else {
<b class="nc"><i>1708</i>&nbsp;                            out.writeShort(j);</b>
<i>1709</i>&nbsp;                        }
<b class="nc"><i>1710</i>&nbsp;                        break;</b>
<i>1711</i>&nbsp;                    }
<i>1712</i>&nbsp;                }
<i>1713</i>&nbsp;            }
<i>1714</i>&nbsp;
<b class="fc"><i>1715</i>&nbsp;            out.writeBoolean(iTailZone != null);</b>
<b class="fc"><i>1716</i>&nbsp;            if (iTailZone != null) {</b>
<b class="fc"><i>1717</i>&nbsp;                iTailZone.writeTo(out);</b>
<i>1718</i>&nbsp;            }
<b class="fc"><i>1719</i>&nbsp;        }</b>
<i>1720</i>&nbsp;
<i>1721</i>&nbsp;        public boolean isCachable() {
<b class="fc"><i>1722</i>&nbsp;            if (iTailZone != null) {</b>
<b class="fc"><i>1723</i>&nbsp;                return true;</b>
<i>1724</i>&nbsp;            }
<b class="fc"><i>1725</i>&nbsp;            long[] transitions = iTransitions;</b>
<b class="fc"><i>1726</i>&nbsp;            if (transitions.length &lt;= 1) {</b>
<b class="nc"><i>1727</i>&nbsp;                return false;</b>
<i>1728</i>&nbsp;            }
<i>1729</i>&nbsp;
<i>1730</i>&nbsp;            // Add up all the distances between transitions that are less than
<i>1731</i>&nbsp;            // about two years.
<b class="fc"><i>1732</i>&nbsp;            double distances = 0;</b>
<b class="fc"><i>1733</i>&nbsp;            int count = 0;</b>
<i>1734</i>&nbsp;
<b class="fc"><i>1735</i>&nbsp;            for (int i=1; i&lt;transitions.length; i++) {</b>
<b class="fc"><i>1736</i>&nbsp;                long diff = transitions[i] - transitions[i - 1];</b>
<b class="fc"><i>1737</i>&nbsp;                if (diff &lt; ((366L + 365) * 24 * 60 * 60 * 1000)) {</b>
<b class="fc"><i>1738</i>&nbsp;                    distances += (double)diff;</b>
<b class="fc"><i>1739</i>&nbsp;                    count++;</b>
<i>1740</i>&nbsp;                }
<i>1741</i>&nbsp;            }
<i>1742</i>&nbsp;
<b class="fc"><i>1743</i>&nbsp;            if (count &gt; 0) {</b>
<b class="fc"><i>1744</i>&nbsp;                double avg = distances / count;</b>
<b class="fc"><i>1745</i>&nbsp;                avg /= 24 * 60 * 60 * 1000;</b>
<b class="fc"><i>1746</i>&nbsp;                if (avg &gt;= 25) {</b>
<i>1747</i>&nbsp;                    // Only bother caching if average distance between
<i>1748</i>&nbsp;                    // transitions is at least 25 days. Why 25?
<i>1749</i>&nbsp;                    // CachedDateTimeZone is more efficient if the distance
<i>1750</i>&nbsp;                    // between transitions is large. With an average of 25, it
<i>1751</i>&nbsp;                    // will on average perform about 2 tests per cache
<i>1752</i>&nbsp;                    // hit. (49.7 / 25) is approximately 2.
<b class="nc"><i>1753</i>&nbsp;                    return true;</b>
<i>1754</i>&nbsp;                }
<i>1755</i>&nbsp;            }
<i>1756</i>&nbsp;
<b class="fc"><i>1757</i>&nbsp;            return false;</b>
<i>1758</i>&nbsp;        }
<i>1759</i>&nbsp;    }
<i>1760</i>&nbsp;}
</div>
</div>

<div class="footer">
    
    <div style="float:right;">generated on 2016-11-30 03:04</div>
</div>
</body>
</html>
